[{"content":"一句话总结  Queue 先进先出;  要求   了解队列的概念；\n 队列是一个有序列表; 遵循先入先出的原则;    队列的分类；\n 顺序队列：数组； 循环队列：数组； 链式队列：链表；    队列的使用场景；\n 先进先出,线程安全    队列的基本方法；\n     方法名 方法作用 描述     add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常   element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常   offer 添加一个元素并返回true 如果队列已满，则返回false   peek 返回队列头部的元素 如果队列为空，则返回null   poll 移除并返问队列头部的元素 如果队列为空，则返回null   put 添加一个元素 如果队列满，则阻塞   remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常   take 移除并返回队列头部的元素 如果队列为空，则阻塞    ","description":" ","id":2,"section":"posts","tags":["数据结构","队列"],"title":"【数据结构和算法__队列】","uri":"https://lu-dashuai.github.io/posts/blogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95__%E9%98%9F%E5%88%97/"},{"content":"前言  海洋兄一个写前端的同志都买了一个阿里云来学习数据库，苦于linux下安装报错，特把阿里云的账号密码发给我，让我来试着安装一下。我自己的阿里云也是看着教程稀里糊涂的安装好了，也没出一篇博客来记录，这次刚好记录下linux的mysql安装，应该要写的比较详细，毕竟一会还要给海洋兄发过去装逼用。嘻嘻!😊~~~~  常用的linux命令 Docker 进程相关命令  启动docker服务:  systemctl start docker  停止docker服务:  systemctl stop docker  重启docker服务:  systemctl restart docker  查看docker服务状态:  systemctl status docker  设置开机启动docker服务:  systemctl enable docker Docker 镜像相关命令  查看镜像: 查看本地所有的镜像  docker images docker images –q # 查看所用镜像的id  搜索镜像:从网络中查找需要的镜像  docker search 镜像名称  拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。 如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。  docker pull 镜像名称  删除镜像: 删除本地镜像  docker rmi 镜像id # 删除指定本地镜像 docker rmi `docker images -q` # 删除所有本地镜像 Docker 容器相关命令  查看容器  docker ps # 查看正在运行的容器 docker ps –a # 查看所有容器  创建并启动容器  docker run 参数 参数说明：\n• -i：保持容器运行。通常与-t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。\n• -t：为容器重新分配一个伪输入终端，通常与-i 同时使用。\n• -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用dockerexec 进入容器。退出后，容器不会关闭。\n• -it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器\n• \u0026ndash;name：为创建的容器命名。\n 进入容器  docker exec -t -i \u0026lt;id/container_name\u0026gt; /bin/bash  停止容器  docker stop 容器名称  启动容器  docker start 容器名称  删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除  docker rm 容器名称  查看容器信息  docker inspect 容器名称 详细安装步骤 卸载旧mysql  使用SecureCRT.exe来连接，输入公网ip，用户名和密码\u0026hellip;连上了\n 因为他之前安装过mysql，然后安装失败，我需要彻底卸载\u0026hellip;使用以下命令查看当前安装mysql情况，查找以前是否装有mysql  rpm -qa|grep -i mysql 3. 显示安装过，那么下一步删除\nrpm -ev MySQL-client-5.5.25a-1.rhel5 rpm -ev MySQL-server-5.5.25a-1.rhel5  删除失败的话使用下面的命令  rpm -ev MySQL-client-5.5.25a-1.rhel5 --nodeps 或者 rpm -e --noscripts MySQL-client-5.5.25a-1.rhel5 查找之前老版本mysql的目录、并且删除老版本mysql的文件和库  find / -name mysql  查找结果\n  删除目录  rm -rf 目录名 6. 删除配置\n 注意：卸载后/etc/my.cnf不会删除，需要进行手工删除  rm -rf /etc/my.cnf 重新检查安装情况  rpm -qa|grep -i mysql  关于Linux/Unix系统的设计思想：没有消息就是最好的消息  docker安装 1、yum 包更新到最新 yum update 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2 3、 设置yum源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 4、 安装docker，出现输入的界面都按 y yum install -y docker-ce 5、 查看docker版本，验证是否验证成功 docker -v  阿里云官方安装  6. 配置阿里云镜像加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-'EOF' { \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://dq7u363w.mirror.aliyuncs.com\u0026quot;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker docker-mysql的安装  下载最新版  docker pull mysql 查看镜像  docker images 在opt下创建文件夹  cd /opt/ mkdir mysql_docker cd mysql_docker/ echo $PWD 启动mysql容器，在var/lib/docker/containers/下查看容器  docker run --name mysqlserver -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d -i -p 3306:3306 mysql:latest cd /var/lib/docker/containers/ 查看mysql进程  docker ps -a 进入mysql容器，并登陆mysql  docker exec -it mysqlserver bash mysql -uroot -p 开启远程访问权限  use mysql; 命令：select host,user from user; 命令：ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; 命令：flush privileges; 阿里云配置3306端口后，navite直接链接  结束，求表扬🍉 ","description":"","id":3,"section":"posts","tags":["Mysql","Docker"],"title":"linux下docker_mysql的安装并连接","uri":"https://lu-dashuai.github.io/posts/blogs/linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85/"},{"content":"枚举介绍（场景，好处，注意事项） 场景  保证对象的数据安全，有些规范保证类的值只为固定的几个值，比如：星期，性别，季节，http状态码。这些都是一对一的关系，而且也是固定的值，我们都知道404是客户端错误，500是服务端错误。如果提供get/set方法来表示，那么404可能会被set成服务器错误(500)，灵活性大但是容易犯错，导致数据不安全。这时如果有规定为404\u0026mdash;\u0026gt;客户端错误，有个一一对应的关系，也无法修改。这就是规范。  好处  数据安全，设定规范； 使用方便，代码简洁；  注意事项  枚举类中的每个数据都可以调用枚举类的所有方法; 所有枚举值都是public , static , final的。注意这一点只是针对于枚举值，我们可以和在普通类里面定义 变量一样定义其它任何类型的非枚举变量，这些变量可以用任何你想用的修饰符。 枚举类继承Enum，所以不能该类不可以继承其他类(java单继承，多实现); 枚举类中的看着像属性的东西，其实都是每一个对象，当枚举类中有抽象方法，那么该类中的创建的类，必须实现抽象方法。  1 2 3 4 5 6 7 8 9 10 11 12  WHITE(\u0026#34;白\u0026#34;,0){//必须实现  @Override public void say() { } }, BLACK(\u0026#34;黑\u0026#34;,1){ @Override public void say() { } }; //抽象方法 public abstract void say();   它不能有public的构造函数，这样做可以保证客户代码没有办法新建一个enum的实例。(保证对象数据安全); Enum默认实现了java.lang.Comparable接口。 Enum还有一个oridinal的方法，这个方法返回枚举值在枚举类种的顺序，这个顺序根据枚举值声明的顺序而定，这里Color.Red.ordinal()返回0。 枚举使用的单例设计模式，构造器私有  代码场景 场景  在编写五子棋程序时，发现黑色和白色可以用枚举来表示，于是学习了枚举，代码如下：  代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  enum Chesspiece{ WHITE(\u0026#34;白\u0026#34;,0),//枚举值直接写死为黑和白  BLACK(\u0026#34;黑\u0026#34;,1); private String color;//枚举值括号后面对应的黑白两个描述  private int type;//枚举值后面的type，其实也可以用ordinal()方法来表示  Chesspiece(String color,int type){//必须私有构造，默认也是私有构造  this.color = color; this.type = type; } public String getColor(){//只提供get方法，保证无法更改其值  return color; } public int getType(){ return type; } @Override public String toString() { return \u0026#34;Chesspiece{\u0026#34; + \u0026#34;color=\u0026#39;\u0026#34; + color + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, type=\u0026#34; + type + \u0026#39;}\u0026#39;; } /** * API 的调用 */ public static void main(String[] args) { //获取下标，重要  int ordinal = Chesspiece.WHITE.ordinal(); System.out.printf(\u0026#34;%d\\n\u0026#34;,ordinal);//0  //获取属性名  String name = Chesspiece.WHITE.name(); System.out.printf(\u0026#34;%s\\n\u0026#34;,name);//WHITE  //重写toString()方法后打印  String white = Chesspiece.WHITE.toString();//本来底层返回的是name  System.out.println(white);//Chesspiece{color=\u0026#39;白\u0026#39;, type=0}  //返回get的结果  int type = Chesspiece.BLACK.getType(); System.out.println(type);//1  String color = Chesspiece.BLACK.getColor(); System.out.println(color);//黑  } }   ","description":"","id":4,"section":"posts","tags":["枚举","Java基础"],"title":"java基础之__枚举","uri":"https://lu-dashuai.github.io/posts/blogs/java%E5%9F%BA%E7%A1%80__%E6%9E%9A%E4%B8%BE/"},{"content":"一句话总结  解决二维数组存储无效数据的痛点，节省存储空间。  要求  了解稀疏数组的概念   如果一个数组(包括多维数组)中的大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组，节约空间。  用代码实现稀疏数组转换为二维数组 稀疏数组的使用场景   可以使用稀疏数组来保留类似前面的二维数组(棋盘，地图等)  场景  五子棋盘，解决二维数组存储大量无效数据的问题，可以使存取量变小。  二维数组\u0026amp;稀疏数组  两种都是数据结构  图例  将棋盘实例化成二维数组\n 思路上将二维数组转化为稀疏数组\n 代码中将稀疏数组存盘，转化为二维数组显示   此时稀疏数组的第一行分别为：\n|二维数组的行数 | 二维数组的列数 | 有效值\n|二维数组中的第一个有效值的x值|二维数组中的第一个有效值的y值|有效值的值\n\u0026hellip;  代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271  package com.atguigu.sparsearray; import java.util.Scanner; /** * 一些声明信息 * Description: 五子棋游戏----\u0026gt;稀疏数组 * date: 2020/5/15 14:44\u0026lt;br/\u0026gt; * * @author Jack.Lu\u0026lt;br /\u0026gt; * @since JDK 1.8 */ public class Test { private static int[][] table;//全局二维数组  private static int[][] sparseArr;//全局稀疏数组  private static int num = 0;//记录白棋先下还是黑棋先下  private static int sum = 0;//记录下棋的个数  /** * 用来执行二维数组的代码 * @param args */ // public static void main(String[] args) { // // 1. 创建空五子棋盘 // Scanner scanner = new Scanner(System.in); // System.out.println(\u0026#34;请输入要创建的棋盘【行】数（注意输入数字）：\u0026#34;); // int x = scanner.nextInt(); // System.out.println(\u0026#34;请输入要创建的棋盘【列】数（注意输入数字）：\u0026#34;); // int y = scanner.nextInt(); // createTableNormal(x, y); // // boolean bo = false; // while (!bo) { // if (num % 2 == 0) {//默认白棋先下 // System.out.println(Chesspiece.WHITE.getColor()+\u0026#34;为\u0026#34;+Chesspiece.WHITE.getType()); // System.out.println(\u0026#34;请输入x坐标：\u0026#34;); // x = scanner.nextInt(); // System.out.println(\u0026#34;请输入y坐标：\u0026#34;); // y = scanner.nextInt(); // downTable(x,y,Chesspiece.WHITE.getType()); // }else { // System.out.println(Chesspiece.BLACK.getColor()+\u0026#34;为\u0026#34;+Chesspiece.BLACK.getType()); // System.out.println(\u0026#34;请输入x坐标：\u0026#34;); // x = scanner.nextInt(); // System.out.println(\u0026#34;请输入y坐标：\u0026#34;); // y = scanner.nextInt(); // downTable(x,y,Chesspiece.BLACK.getType()); // } // num++; // } // }  /** * 用于执行稀疏数组的代码 * @param args */ public static void main(String[] args) { // 1. 创建空五子棋盘  Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入要创建的棋盘【行】数（注意输入数字）：\u0026#34;); int x = scanner.nextInt(); System.out.println(\u0026#34;请输入要创建的棋盘【列】数（注意输入数字）：\u0026#34;); int y = scanner.nextInt(); createTableSparseArray(x, y); //2. 将稀疏表 转化为 普通表 输出  SparseArrayToNomal(); boolean bo = false; while (!bo) { if (num % 2 == 0) {//默认白棋先下  System.out.println(Chesspiece.WHITE.getColor() + \u0026#34;为\u0026#34; + Chesspiece.WHITE.getType()); System.out.println(\u0026#34;请输入x坐标：\u0026#34;); x = scanner.nextInt(); System.out.println(\u0026#34;请输入y坐标：\u0026#34;); y = scanner.nextInt(); downSparseTable(x, y, Chesspiece.WHITE.getType()); } else { System.out.println(Chesspiece.BLACK.getColor() + \u0026#34;为\u0026#34; + Chesspiece.BLACK.getType()); System.out.println(\u0026#34;请输入x坐标：\u0026#34;); x = scanner.nextInt(); System.out.println(\u0026#34;请输入y坐标：\u0026#34;); y = scanner.nextInt(); downSparseTable(x, y, Chesspiece.BLACK.getType()); } num++; } } /** * 稀疏数组下棋 * @param x * @param y * @param type */ private static void downSparseTable(int x, int y, int type) { sum = sum +1; int m = sparseArr.length+1;//代表行  int n = sparseArr[0].length;//代表列  int[][] tmp = new int[m][n];//该稀疏数组保持 x 的+1扩容，y还是三行  //原表的拷贝  for (int i=0;i\u0026lt;sparseArr.length;i++){ tmp[i][0] = sparseArr[i][0]; tmp[i][1] = sparseArr[i][1]; tmp[i][2] = sum; } tmp[sum][0]=x; tmp[sum][1]=y; tmp[sum][2]=type; sparseArr = tmp; //打印稀疏数组  System.out.println(\u0026#34;打印稀疏表：\u0026#34;); for (int i = 0; i \u0026lt; sparseArr.length; i++) { //看有几行  for (int j = 0; j \u0026lt; sparseArr[0].length; j++) {//打印每列  System.out.printf(\u0026#34;%d\\t\u0026#34;, sparseArr[i][j]); } System.out.println(); } //将稀疏数组转换为二维数组  SparseArrayToNomal(); } /** * 将初始化稀疏表转化为普通表进行输出 */ private static void SparseArrayToNomal() { //处理稀疏数组第一行数据  int x = sparseArr[0][0]; int y = sparseArr[0][1]; table = new int[x][y];//稀疏表的00为行数，01为列数  //处理稀疏数组第二行开始后的数据  //for 循环 稀疏表 赋值给 二维表  int val = 0; for (int i=1;i\u0026lt;sparseArr.length;i++){ x = sparseArr[i][0];//横坐标  y = sparseArr[i][1];//纵坐标  val = sparseArr[i][2];//值  table[x][y]=val; } System.out.println(\u0026#34;将稀疏表转化为普通表进行输出：\u0026#34;); for (int i = 0; i \u0026lt; table.length; i++) { for (int j = 0; j \u0026lt; table[0].length; j++) { System.out.printf(\u0026#34;%d\\t\u0026#34;,table[i][j]); } System.out.println(); } } /** * 创建五子棋地图 * * @param x 几行 * @param y 几列 */ public static void createTableNormal(int x, int y) { //int的默认值为0  table = new int[x][y]; for (int i = 0; i \u0026lt; x; i++) { //看有几列  for (int j = 0; j \u0026lt; y; j++) {//打印每行  System.out.printf(\u0026#34;%d\\t\u0026#34;, table[i][j]); } System.out.println(); } } /** * 创建五子棋地图 通过稀疏数组 * * @param x * @param y 稀疏数组：一共有三列，坐标为（0,0）表示棋盘的总行数，（0，1）表示棋盘的总列数，（0，2）表示棋盘非0的个数 */ public static void createTableSparseArray(int x, int y) { sparseArr = new int[1][3];//初始化稀疏数组，只有表示行列的值  sparseArr[0][0] = x; sparseArr[0][1] = y; sparseArr[0][2] = sum; //打印稀疏数组  System.out.println(\u0026#34;打印稀疏表：\u0026#34;); for (int i = 0; i \u0026lt; 1; i++) { //看有几行  for (int j = 0; j \u0026lt; 3; j++) {//打印每列  System.out.printf(\u0026#34;%d\\t\u0026#34;, sparseArr[i][j]); } System.out.println(); } } /** * table的展示 */ public static void showTable() { for (int i = 0; i \u0026lt; table.length; i++) { for (int j = 0; j \u0026lt; table[i].length; j++) { System.out.printf(\u0026#34;%d\\t\u0026#34;, table[i][j]); } System.out.println(); } } /** * 进行下棋 * * @param x 放到的行数 * @param y 放到的列数 * @param */ public static void downTable(int x, int y, int type) { table[x][y] = type; showTable(); } } /** *使用枚举来表示黑白色棋子 * */ enum Chesspiece { WHITE(\u0026#34;白\u0026#34;, 1), BLACK(\u0026#34;黑\u0026#34;, 2); private String color; private int type; Chesspiece(String color, int type) { this.color = color; this.type = type; } public String getColor() { return color; } public int getType() { return type; } @Override public String toString() { return \u0026#34;Chesspiece{\u0026#34; + \u0026#34;color=\u0026#39;\u0026#34; + color + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, type=\u0026#34; + type + \u0026#39;}\u0026#39;; } public static void main(String[] args) { //获取下标  int ordinal = Chesspiece.WHITE.ordinal(); System.out.printf(\u0026#34;%d\\n\u0026#34;, ordinal);//0  //获取属性名  String name = Chesspiece.WHITE.name(); System.out.printf(\u0026#34;%s\\n\u0026#34;, name);//WHITE  //重写toString()方法后打印  String white = Chesspiece.WHITE.toString();//本来底层返回的是name  System.out.println(white);//Chesspiece{color=\u0026#39;白\u0026#39;, type=0}  //返回get的结果  int type = Chesspiece.BLACK.getType(); System.out.println(type);//1  String color = Chesspiece.BLACK.getColor(); System.out.println(color);//黑  } }   ","description":"","id":5,"section":"posts","tags":["稀疏数组","数据结构"],"title":"数据结构和算法__稀疏数组","uri":"https://lu-dashuai.github.io/posts/blogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95__%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"content":" github地址   因项目还在完善，并有部分密钥，之后开源。   介绍：程序设计初衷，是想解决日常工作中一些每天都要重复工作的内容。例如：   每天都要检查小红书的解密服务是否挂起（发送请求，看是否返回错误的状态码） 每天都要检查淘宝天猫的解密服务是否挂起（发送请求，检查是否返回错误的状态码） 希望每天给张叶发送一封邮件，有关气温，有关生活（爬虫）。 待完善\u0026hellip;   程序设计：   使用springboot、quartz、springboot-email; 需要设计每个线程单独运行，执行一条定时任务。 无任何web界面,后期如果需要，就用vue，写前后端分离的项目。使用nginx解决跨域问题。 后期可以添加需要持久化的操作，就用mybatis-plus。 最好能达到自动化部署（docker）   希望学习到的技术：   springboot-email nginx quartz(重点) docker（重点）  日记 20200412 今天给自己剃了头。\n完成email的单元测试。\n20200413 配置动态定时器，参考github项目; BeanFactoryPostProcessor接口牛逼之处，mybatis和spring集成后自定义mapper接口，没有实现类，但是spring可以自动注入。\n参考博客，看不懂，不要紧，spring的高级特性还有很多地方需要学习，之后慢慢补;  20200415  今天初始化了前端你的项目，表格也写好了，但是还差一些按钮的功能，交给茶姐 完成后台的查询所有有用任务的接口。等待联调。   问题:1. 前后端分离的时候 nginx 解决跨域问题。  20200416   完成淘宝天猫的业务代码的编写，指定为job1;\n  完成小红书的业务代码的编写，指定为job2；\n  corn 表达式的编写，corn测试\n  完成数据库的迁移\n siqi-yaolingsan-san-yaojiuliu 库名：quartz    忘记mysql密码参考博客\n 使用 service 启动：service mysqld start 使用 service 关闭：service mysqld stop 异常：Your password does not satisfy the current policy requirements\n- 参考博客异常解决\n- MySQL只能服务器登录，远程链接失败\n- 远程端口telnet开启测试\n- 给防火墙开启端口    启动、关闭、查看\n 后台启动   java -jar xxx.jar \u0026gt; log.file \u0026amp;  关闭   ps -ef|grep java  查看日志   cat log.file   复制命令\n   pscp xxx root@47.103.3.196:/jack/war 本地发送邮件成功，但是部署到阿里云服务器发送邮件失败。   参考博客  ","description":"","id":6,"section":"posts","tags":["Quartz","Nginx"],"title":"自定义发送邮件项目","uri":"https://lu-dashuai.github.io/posts/blogs/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"content":"Hi! I\u0026rsquo;m Jack!😊 ","description":"Yes","id":11,"section":"","tags":null,"title":"About","uri":"https://lu-dashuai.github.io/about/"},{"content":"感谢  感谢b站up主程序🐏提供思维导图，让我在技术路上不迷路~\n  ","description":"用来格式化tag \u0026\u0026 categories","id":13,"section":"myTag","tags":["Java基础","JVM","并发/多线程","数据结构","算法","TCP/UDP协议","HTTP/HTTPS协议","Session/Cookie","Mysql","SQL书写","SQL优化","数据库事务隔离级别","数据库索引","数据库锁","Shell脚本","Git","SVN","Maven","Gradle","Spring","SpringMVC","SpringBoot","Nginx","Tomcat","Redis","RabbitMQ","Dubbo","Mybatis","Nuzt","SpringCloud","Shiro","SSO","Quartz","Docker","Node","Vue","Jenkins"],"title":"需要不断学习的技术栈","uri":"https://lu-dashuai.github.io/mytag/tag-%E9%9C%80%E8%A6%81%E4%B8%8D%E6%96%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":14,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://lu-dashuai.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":15,"section":"gallery","tags":null,"title":"Photo","uri":"https://lu-dashuai.github.io/gallery/photo/"},{"content":"项目状态：已出 项目视频 -B站看片\n功能模块自己看片，本项目价格较低。 另有这个项目的共享单车版本-功能一样，也可cs；\n 项目功能 概览  项目使用技术  jsp servlet mysql hibernate 工具：Intellij IDEA  联系  q: 970638341  ","description":"","id":18,"section":"posts","tags":null,"title":"【毕业设计 共享篮球 or 共享单车】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%85%B1%E4%BA%AB%E7%AF%AE%E7%90%83/"},{"content":"项目状态  未出  视频地址  B站看片  系统概要 本系统为用户提供实现了以下功能：\n1.登录功能：\n系统为单用户系统，为用户分配了用户名和密码。用户必须先登录，进入操作界面。用户输入ID和密码，通过服务器验证方可运行，否则显示消息提示。\n2.网站前台功能：\n浏览：博主个人信息、文章； \n发表：留言，评论\n3.网站后台功能： \n发布文章\n文章管理\n页面管理\n评论管理\n分类/标签\n文件管理\n友情链接\n系统设置\n本项目是采用了springboot，spring，mybatis框架进行设计与实现的。项目采用了jdk1.8的版本，web服务器采用tomcat 8，数据库服务器采用了mysql，前台页面的显示使用了JavaScript，CSS，jquery等技术进行编写。使用java面向对象的思想对类和接口进行设计，使网站具有可扩展性，便于维护等优点。\n项目截图 技术选型 后台技术选型  Spring SpringBoot Mybatis 等。。。  前端技术选型  easyUI、Bootstrap 等很多  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat、Git 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.0  联系  q: 970638341  ","description":"","id":19,"section":"posts","tags":null,"title":"【毕业设计 springboot个人博客系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-springboot%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  未出  视频地址  B站看片  系统概要 本系统为用户提供实现了以下功能：\n1.登录功能：\n系统为单用户系统，为用户分配了用户名和密码。用户必须先登录，进入操作界面。用户输入ID和密码，通过服务器验证方可运行，否则显示消息提示。\n2.网站前台功能：\n浏览：博主个人信息、文章； \n发表：留言，评论\n3.网站后台功能： \n用户管理模块：实现用户信息及密码的修改 \n博文的分类与管理模块：实现分类的增、删、改 \n评论管理模块：实现删除评论功能 \n留言管理模块：实现删除、回复评论功能 \n系统管理模块：实现博客版面的定义与管理 博客的数据统计\n本项目是采用了springmvc，spring，mybatis框架进行设计与实现的。项目采用了jdk1.8的版本，web服务器采用tomcat 8，数据库服务器采用了mysql，前台页面的显示使用了JavaScript，CSS，jquery等技术进行编写。使用java面向对象的思想对类和接口进行设计，使网站具有可扩展性，便于维护等优点。\n第一章\t绪论\t1\n第二章 相关技术介绍\t2\n2.1 B/S 简介\t2\n2.2 JAVA 简介\t2\n2.3 JSP 简介\t3\n2.4 springMVC简介\t3\n第三章 可行性分析\t4\n3.1 技术可行性分析\t4\n3.2 经济可行性分析\t4\n3.3 操作可行性\t4\n3.4 法律可行性\t4\n第四章 系统设计\t5\n4.1 系统总流程\t5\n4.2 博主用例\t6\n4.3 游客用例\t7\n4.4 系统类\t9\n4.5 E-R图\t11\n4.6 系统表设计\t14\n第五章 系统实现\t16\n5.1 登录模块\t16\n5.1.1 博主登录\t16\n5.2 博客管理模块：\t19\n5.2.1 博客查询\t19\n5.2.2 博客新建\t21\n5.2.3 博客修改\t23\n5.2.4 博客删除\t25\n5.3 博客类别管理模块\t26\n5.3.1 添加博客类别\t26\n5.3.2 修改博客类别\t28\n5.3.3 删除博客类别\t30\n5.3.4 显示博客类别\t32\n5.4 评论管理模块\t34\n5.4.1 审核评论\t34\n5.4.2 删除评论\t36\n第六章 系统测试\t38\n6.1 前台模块测试\t38\n6.2 后台模块测试\t38\n参考文献\t41\n致 谢\t42\n项目截图 技术选型 后台技术选型  Spring SpringMVC Mybatis 等。。。  前端技术选型  easyUI、Bootstrap 等很多  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat、Git 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.0  联系  q: 970638341  ","description":"","id":20,"section":"posts","tags":null,"title":"【毕业设计 SSM个人博客系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-ssm%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  已出  视频地址  B站看片  系统概要 仓库管理系统总共分为两个大的模块，分别是系统模块和业务模块。其中系统模块和业务模块底下又有其子模块。\n功能模块 一、业务模块 1、客户管理 客户列表 客户分页和模糊查询 客户添加、修改、删除、批量删除 2、供应商管理 供应商列表 供应商分页和模糊查询 供应商添加、修改、删除、批量删除 3、商品管理 商品列表 商品分页和模糊查询 商品添加、修改、删除、商品图片的上传 4、商品进货管理 商品进货列表 商品进货分页和模糊查询 商品进货添加、修改、删除、商品退货 5、商品退货管理 商品退货列表 商品退货分页和模糊查询 商品退货删除 6、商品销售管理 商品销售列表 商品销售分页和模糊查询 商品销售添加、修改、删除、商品销售退货 7、商品销售退货管理 商品销售退货列表 商品销售退货分页和模糊查询 商品销售退货删除 二、系统模块 1、用户登陆 校验用户名、密码以及验证码 登陆成功将登陆信息写入登陆日志 未登录直接访问服务器资源进行拦截 2、菜单管理 全查询菜单和根据左边的树查询不同菜单 菜单的添加、修改、删除 3、角色管理 全查询角色和模糊查询 角色的添加、修改、删除以及给角色分配权限 4、用户管理 全查询用户和模糊查询 用户的添加、修改、删除、重置密码以及给用户分配角色 5、部门管理 全查询部门、模糊查询以及根据左边的树查询不同的部门 部门的添加、修改、删除 技术选型 后台技术选型  SpringBoot Shiro MybatisPlus  前端技术选型  LayUI、DTree  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat、Git 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.0 代码托管平台：GitHub  联系  q: 970638341  ","description":"","id":21,"section":"posts","tags":null,"title":"【毕业设计 仓库管理系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  已出  视频地址  B站看片 这个系统非常适合做毕业设计，页面简单大方，功能完善； 本系统可以更改为任何类别的和商城有关的系统  技术选型 后台技术选型  SpringBoot Mybatis 等\u0026hellip;  前端技术选型  LayUI、DTree  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat、Git 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.0  系统概要 商城系统总共分为3个大的模块，分别是前台商城页面、个人中心模块和后台业务模块。\n项目截图 联系  q: 970638341  ","description":"","id":22,"section":"posts","tags":null,"title":"【毕业设计 在线商城系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  未出  视频地址  B站看片  技术  项目用到的相关技术、工具等 开发平台及工具：Windows 8 | IDEA 涉及的编程语言：Java | JavaScript | HTML 涉及的框架技术：Struts2 | Spring | Hibernate 其他技术：Maven | CSS | JQuery | Ajax | JSON | JSP | Servlet 数据库：MySQL 5.6 服务器：Tomcat 7.x  项目截图 联系  q: 970638341  ","description":"","id":23,"section":"posts","tags":null,"title":"【毕业设计 失物招领平台】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%A4%B1%E7%89%A9%E6%8B%9B%E9%A2%86%E5%B9%B3%E5%8F%B0/"},{"content":"项目状态  未出  视频地址  B站看片  系统概要 本系统为用户提供实现了以下功能：\n 登录功能：\n系统为单用户系统，为用户分配了用户名和密码。用户必须先登录，进入操作界面。用户输入ID和密码，通过服务器验证方可运行，否则显示消息提示。 控制台：\n用于展示当前系统所有的数据表格 申购设备：\n提交申请进行设备的购买，查询当前设备状态 设备列表 设备维修 设备类型 申购设备 报废设备查询 维修记录 系统监控  技术选型 后台技术选型  前端采用得是layui框架\u0026mdash;-\u0026gt;传送门：layui官网 admin用的是ok-admin\u0026mdash;-\u0026gt;传送门 ok-admin 前后端全部Ajax数据交互 后端无框架，采用原生servlet/jsp 数据库连接池采用druid  开发环境  JDK 1.8 maven 3.6 mysql 5.6 tomcat 7.0 idea 2019.9  项目截图 联系  q: 970638341  ","description":"","id":24,"section":"posts","tags":null,"title":"【毕业设计 实验室设备管理系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E9%AA%8C%E5%AE%A4%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  已出  视频地址  B站看片 这个系统非常适合做毕业设计，页面简单大方，功能完善； 本系统可以更改为任何学校的管理系统，支持定制化更改学校；  技术选型 后台技术选型  Spring JDBC shrio权限管理 servlet、jstl、el表达式  前端技术选型  html jsp javascript jq css bootstrap tree组件  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat 服务器：Tomcat 8.5 数据库：MySQL 5.0  系统概要 商城系统总共分为3个大的模块，分别是管理员模块、宿舍老师模块和学生信息模块。\n 大模块下的小模块功能非常多，项目代码冗余严重，可能需要电脑配置稍高的环境，但是确实良心代码。 小模块功能请看图。⬇  项目截图 联系  q: 970638341  ","description":"","id":25,"section":"posts","tags":null,"title":"【毕业设计 宿舍管理系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%AE%BF%E8%88%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"content":"在线预览  B站查看功能演示  主要功能介绍  文章发布系统是一个管理系统，游客注册后可以登录网站属于文章进行评论，管理员可以登录进入管理员中心对网站信息进行管理，对文章进行发布以及管理。极大的方便的网民，是广大网民点开浏览器，输入网址，即可浏览相关信息。  后台技术选型  SpringBoot Mybatis Spring shrio权限管理 servlet、jstl、el表达式  前端技术选型  LayUI、DTree html jsp javascript jq css bootstrap tree组件  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.6  模块介绍  前台注册 前台登录 前台新闻查看  国内文章 国际文章 本地文章 娱乐文章 政要文章   管理员登录  个人信息 在线投稿 系统管理   用户登录  前台信息展示 个人信息管理    项目截图 联系 q: 970638341\n","description":"","id":26,"section":"posts","tags":null,"title":"【毕业设计 文章/小说/新闻 发布平台（在线投稿系统）】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%B9%B3%E5%8F%B0/"},{"content":"在线预览  B站查看功能演示  主要功能介绍  新闻管理系统是一个前后台系统，游客注册后可以登录网站可以对文章进行评论，管理员可以登录进入管理员中心对网站信息进行管理，对新闻进行发布以及管理。极大的方便的网民，是广大网民点开浏览器，输入网址，即可浏览相关信息。  技术介绍  由于论文东西非常全面，这里不再详细介绍  模块介绍（有往届论文，各种er图都有） 第一章 绪论\t1\n第二章 相关技术介绍\t3\n2.1 JAVA简介\t3\n2.2 JSP技术简介\t3\n2.3 MySQL数据库简介\t4\n第三章 系统设计\t5\n3.1功能需求\t5\n3.2性能需求\t6\n3.3 可靠性和用户界面需求\t7\n3.4系统E-R模型\t8\n3.5 系统流程分析\t9\n第四章 系统功能实现\t11\n4.1 系统架构\t11\n4.2 系统设计\t12\n4.3 系统数据库设计\t13\n第五章 系统功能实现\t15\n5.1前台新闻发布系统界面\t15\n5.1.1用户注册界面\t16\n5.1.2用户登入界面\t17\n5.1.3用户浏览新闻界面\t18\n5.2后台新闻界面系统\t19\n5.21后台管理界面\t21\n5.2.2新闻栏目管理界面\t21\n5.2.3新闻资讯管理界面\t23\n第六章 系统测试\t27\n6.1测试概述\t27\n6.2测试环境\t27\n6.3测试内容\t27\n第七章 总结\t31\n致 谢\t33\n项目截图 联系 q: 970638341\n","description":"","id":27,"section":"posts","tags":null,"title":"【毕业设计 新闻/文章/小说/ 发布平台（在线投稿系统）二】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E6%96%B0%E9%97%BB%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-/"},{"content":"对数据表操作之前备份一下是个好习惯  备份表结构  1  create table table_bak like table_name;   备份表数据  1  insert into table_bak select * from table_name;   删除原来主键字段(如id)  1  alter table table_name drop id;   添加主键，自增，放在第一位  1  alter table table_name add id int(11) primary key auto_increment first;   搞定\n检查没问题的话，备份的表可以删了  1  delete from table_bak;   ","description":"","id":28,"section":"posts","tags":["Mysql"],"title":"mysql让主键id重新排序","uri":"https://lu-dashuai.github.io/posts/blogs/mysql%E8%AE%A9%E4%B8%BB%E9%94%AEid%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F/"}]