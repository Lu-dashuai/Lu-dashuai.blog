[{"content":"好文转载  阿里面试官问我Mybatis，我怂了吗？ （一）mybatis-plus详细介绍 （二）springboot+mybatis plus快速构建项目 （三）springboot + mybatis plus集成AutoGenerator快速搭建项目 （四）springboot + mybatis plus详细拆解CRUD （五）springboot + mybatis plus强大的条件构造器queryWrapper、updateWrapper  ","description":" ","id":2,"section":"posts","tags":["Mybatis"],"title":"Mybatis Plus","uri":"https://lu-dashuai.github.io/posts/blogs/mybatis-plus/"},{"content":"\u0026ldquo;# mybatis\u0026rdquo;\nmybatis使用示例 github地址  地址  配置  因为mybatis-plus完全兼容 mybatis ，所以在测试mybatis的逆向工程时，无需引入mybatis相关依赖，只用使用之前引入的mybatis-plus的依赖；  1 2 3 4 5 6  \u0026lt;!--mybatis-plus 依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    引入mybatis的逆向工程插件  1 2 3 4 5 6 7 8 9 10  \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;overwrite\u0026gt;true\u0026lt;/overwrite\u0026gt; \u0026lt;!--这里配置generatorConfig.xml的位置--\u0026gt; \u0026lt;configurationFile\u0026gt;src/main/resources/generator/generatorConfig.xml\u0026lt;/configurationFile\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt;    yml中的配置  1 2 3 4 5 6 7 8 9 10 11 12  #mybatis的相关配置mybatis:#mapper配置文件mapper-locations:classpath:mapper/*.xmltype-aliases-package:com.bds.mybatisplus.dao#开启驼峰命名# configuration:# map-underscore-to-camel-case: truelogging:level:com.bds.mybatisplus.dao:debug   在src/main/resources/generator下生成 generatorConfig.xml 文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026#34;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026#34;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--\u0026gt; \u0026lt;classPathEntry location=\u0026#34;D:\\maven-repository\\mysql\\mysql-connector-java\\8.0.20\\mysql-connector-java-8.0.20.jar\u0026#34;/\u0026gt; \u0026lt;context id=\u0026#34;mybatis\u0026#34; targetRuntime=\u0026#34;MyBatis3\u0026#34;\u0026gt; \u0026lt;commentGenerator\u0026gt; \u0026lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --\u0026gt; \u0026lt;property name=\u0026#34;suppressAllComments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/commentGenerator\u0026gt; \u0026lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34; connectionURL=\u0026#34;jdbc:mysql:///erp\u0026#34; userId=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/jdbcConnection\u0026gt; \u0026lt;!-- \u0026lt;jdbcConnection driverClass=\u0026#34;oracle.jdbc.OracleDriver\u0026#34; connectionURL=\u0026#34;jdbc:oracle:thin:@127.0.0.1:1521:yycg\u0026#34; userId=\u0026#34;yycg\u0026#34; password=\u0026#34;yycg\u0026#34;\u0026gt; \u0026lt;/jdbcConnection\u0026gt; --\u0026gt; \u0026lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --\u0026gt; \u0026lt;javaTypeResolver\u0026gt; \u0026lt;property name=\u0026#34;forceBigDecimals\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/javaTypeResolver\u0026gt; \u0026lt;!-- targetProject:生成PO类的位置，重要！！ --\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026#34;com.bds.mybatisplus.bean\u0026#34; targetProject=\u0026#34;src/main/java\u0026#34;\u0026gt; \u0026lt;!-- enableSubPackages:是否让schema作为包的后缀 --\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;!-- 从数据库返回的值被清理前后的空格 --\u0026gt; \u0026lt;property name=\u0026#34;trimStrings\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/javaModelGenerator\u0026gt; \u0026lt;!-- targetProject:mapper映射文件生成的位置，重要！！ --\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026#34;mapper\u0026#34; targetProject=\u0026#34;src/main/resources\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/sqlMapGenerator\u0026gt; \u0026lt;!-- targetPackage：mapper接口生成的位置，重要！！ --\u0026gt; \u0026lt;javaClientGenerator type=\u0026#34;XMLMAPPER\u0026#34; targetPackage=\u0026#34;com.bds.mybatisplus.dao\u0026#34; targetProject=\u0026#34;src/main/java\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/javaClientGenerator\u0026gt; \u0026lt;!-- 指定数据库表，要生成哪些表，就写哪些表，要和数据库中对应，不能写错！ --\u0026gt; \u0026lt;table tableName=\u0026#34;emp\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tableName=\u0026#34;dept\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt;   逆向工程生成后目录结构  测试类测试逆向工程生成的接口  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  @SpringBootTest class MybatisApplicationTests { @Autowired private EmpMapper empMapper; /** * 通过id删除 */ @Test void contextLoads() { int i = empMapper.deleteByPrimaryKey(7949); System.out.println(\u0026#34;删除成功！！！count=\u0026#34; + i); } /** * 通过id批量删除 * delete from emp WHERE ( id in ( ? , ? , ? , ? ) ) */ @Test void testBachDel(){ EmpExample empExample = new EmpExample(); EmpExample.Criteria criteria = empExample.createCriteria(); ArrayList\u0026lt;Integer\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(1); arrayList.add(4); arrayList.add(3); arrayList.add(2); criteria.andIdIn(arrayList); int i = empMapper.deleteByExample(empExample); System.out.println(\u0026#34;删除的数据为：\u0026#34;+i); } /** * 员工添加 * insert into emp ( empno, ename, job, mgr, hiredate, comm, deptno ) values ( ?, ?, ?, ?, ?, ?, ? ) */ @Test void testInster(){ Emp emp = new Emp(); emp.setEmpno(100); emp.setEname(\u0026#34;jack\u0026#34;); emp.setJob(\u0026#34;java开发\u0026#34;); emp.setMgr(7934); emp.setHiredate(new Date()); emp.setComm(2000); emp.setDeptno(10); int i = empMapper.insertSelective(emp); } /** * 更改 * update emp set comm = 3000 where empno = 100; */ @Test void testUpdate(){ Emp emp = new Emp(); emp.setComm(3000); EmpExample empExample = new EmpExample(); EmpExample.Criteria criteria = empExample.createCriteria(); criteria.andEmpnoEqualTo(100); int i = empMapper.updateByExampleSelective(emp, empExample); System.out.println(i); } /** * 测试qbc查询， * s select id, empno, ename, job, mgr, hiredate, sal, comm, deptno from emp WHERE ( empno in ( ? , ? ) ) */ @Test void test() { EmpExample empExample = new EmpExample(); EmpExample.Criteria criteria = empExample.createCriteria(); ArrayList\u0026lt;Integer\u0026gt; integers = new ArrayList\u0026lt;\u0026gt;(); integers.add(7369); integers.add(7469); criteria.andEmpnoIn(integers); List\u0026lt;Emp\u0026gt; emps = empMapper.selectByExample(empExample); for (Emp e: emps) { System.out.println(e.toString()); } } }   ","description":" ","id":3,"section":"posts","tags":["SpringBoot","Mybatis"],"title":"Mybatis逆向工程","uri":"https://lu-dashuai.github.io/posts/blogs/mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"content":"文档地址  代码地址 文档地址 在线演示  ","description":" ","id":4,"section":"posts","tags":["Maven","SpringBoot","Mybatis","Shiro"],"title":"若依 前后端不分离版学习","uri":"https://lu-dashuai.github.io/posts/blogs/%E8%8B%A5%E4%BE%9D-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%B8%8D%E5%88%86%E7%A6%BB%E7%89%88%E5%AD%A6%E4%B9%A0/"},{"content":"随机睡眠 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //随机睡眠8-16s int random=(int)(Math.random()*8)+8; sleep(\u0026#34;页数[\u0026#34;+page+\u0026#34;],城市：\u0026#34;+task.getCity_name()+\u0026#34;--店铺名\u0026gt;\u0026gt;\u0026#34;+sname+\u0026#34;转短id中\u0026#34;+change_restaurant_id,random); /** * 睡眠倒计时 * @param i */ public static void sleep(String what,int i) { // TODO Auto-generated method stub  for (; i-1\u0026gt;=0; i--) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //1000毫秒就是1秒  logger.info(what+\u0026#34;--倒计时：\u0026#34;+i+\u0026#34;s\u0026#34;); } }   nutz获取数据源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //调用 public static Dao biDao = BiDao.getDao(); public class BiDao { public static Dao getDao() { // 创建一个数据源 \tSimpleDataSource dataSource = new SimpleDataSource(); dataSource.setJdbcUrl(\u0026#34;jdbc:sqlserver://xxxx:xxx;DatabaseName=DC_HWAHAE\u0026#34;); dataSource.setUsername(\u0026#34;xxx\u0026#34;); dataSource.setPassword(\u0026#34;xxx\u0026#34;); // 创建一个NutDao实例,在真实项目中, NutDao通常由ioc托管, 使用注入的方式获得. \tDao dao = new NutDao(dataSource); return dao; } }   执行一条select语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  String sql = \u0026#34;select * from mobile_meituan_731_params_jack WHERE `status`=0 order by rand( ) limit 1; \u0026#34;; List\u0026lt;Param\u0026gt; params = excuteSql(sql, Param.class, dao); /** * 运行sql语句 返回到一个nutz的model list里 * @param sql sql语句 * @param classOfT 模型类名 * @return 一个pojo列表 */ public static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; excuteSql(String sql, Class\u0026lt;T\u0026gt; classOfT,Dao dao){ Sql sq = Sqls.create(sql); sq.setCallback(Sqls.callback.entities()); sq.setEntity(dao.getEntity(classOfT)); dao.execute(sq); return sq.getList(classOfT); }   时间戳转换为时间 1 2 3 4 5 6 7 8 9 10 11  /* * 将时间戳转换为时间 */ public static String stampToDate(String stap){ String time; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:sss\u0026#34;); long lt = new Long(stap); Date date = new Date(lt); time = simpleDateFormat.format(date); return time; }   根据表生成实体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311  package com.bds.app.util; import java.io.File; import java.io.FileWriter; import java.io.PrintWriter; import java.sql.Connection; import java.sql.DatabaseMetaData; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List; public class GenerateEntity { private static final GenerateEntity INSTANCE = new GenerateEntity(); private String tableName;// 表名 \tprivate String[] colNames; // 列名数组 \tprivate String[] colTypes; // 列名类型数组 \tprivate int[] colSizes; // 列名大小数组 \tprivate boolean needUtil = false; // 是否需要导入包java.util.* \tprivate boolean needSql = false; // 是否需要导入包java.sql.* \tprivate static final SimpleDateFormat SDF = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); private static final String SQL = \u0026#34;SELECT * FROM \u0026#34;;// 数据库操作  // TODO 需要修改的地方 \t//jdbc:mysql://rou1.bds-analytics.com:13002/h_bbs_tech \t//jdbc:sqlserver://dchotel.bds-analytics.com:1433;DatabaseName=DC_OTA \tprivate static final String URL = \u0026#34;jdbc:sqlserver://211.152.47.69:1433;DatabaseName=DC_HWAHAE\u0026#34;; private static final String NAME = \u0026#34;bin.e\u0026#34;; private static final String PASS = \u0026#34;hcr@123\u0026#34;; //com.mysql.jdbc.Driver \t//com.microsoft.sqlserver.jdbc.SQLServerDriver \tprivate static final String DRIVER = \u0026#34;com.microsoft.sqlserver.jdbc.SQLServerDriver\u0026#34;; private String packageOutPath = \u0026#34;com.bds.app.model\u0026#34;;// 指定实体生成所在包的路径 \tprivate String authorName = \u0026#34;jack.Lu\u0026#34;;// 作者名字 \tprivate String[] generateTables = { \u0026#34;hwahae_comment_info\u0026#34; };// 指定需要生成的表的表名，全部生成设置为null  /** * 类的构造方法 */ private GenerateEntity() { } /** * @return * @description 生成class的所有内容 * @author paul * @date 2017年8月18日 下午5:30:07 * @update 2017年8月18日 下午5:30:07 * @version V1.0 */ private String parse() { StringBuffer sb = new StringBuffer(); sb.append(\u0026#34;package \u0026#34; + packageOutPath + \u0026#34;;\\r\\n\u0026#34;); sb.append(\u0026#34;\\r\\n\u0026#34;); // 判断是否导入工具包 \tif (needUtil) { sb.append(\u0026#34;import java.util.Date;\\r\\n\u0026#34;); } if (needSql) { sb.append(\u0026#34;import java.sql.*;\\r\\n\u0026#34;); } sb.append(\u0026#34;import org.nutz.dao.entity.annotation.*;\\r\\n\u0026#34;); // 注释部分 \tsb.append(\u0026#34;/**\\r\\n\u0026#34;); sb.append(\u0026#34; * tablename: \u0026#34; + tableName + \u0026#34;\\r\\n\u0026#34;); sb.append(\u0026#34; * \\r\\n\u0026#34;); sb.append(\u0026#34; * auth: \u0026#34; + authorName + \u0026#34;\\r\\n\u0026#34;); sb.append(\u0026#34; * \\r\\n\u0026#34;); sb.append(\u0026#34; * create time: \u0026#34; + SDF.format(new Date()) + \u0026#34;\\r\\n\u0026#34;); sb.append(\u0026#34; */ \\r\\n\u0026#34;); // 实体部分 \tsb.append(\u0026#34;@Table(\\\u0026#34;\u0026#34; + tableName + \u0026#34;\\\u0026#34;)\u0026#34;); sb.append(\u0026#34;\\r\\n\u0026#34;); sb.append(\u0026#34;public class \u0026#34; + getTransStr(tableName, true) + \u0026#34;{\\r\\n\\r\\n\u0026#34;); processAllAttrs(sb);// 属性 \tsb.append(\u0026#34;\\r\\n\u0026#34;); processAllMethod(sb);// get set方法 \tsb.append(\u0026#34;}\\r\\n\u0026#34;); return sb.toString(); } /** * @param sb * @description 生成所有成员变量 * @author paul * @date 2017年8月18日 下午5:15:04 * @update 2017年8月18日 下午5:15:04 * @version V1.0 */ private void processAllAttrs(StringBuffer sb) { for (int i = 0; i \u0026lt; colNames.length; i++) { if (i == 0) { sb.append(\u0026#34; @Id\\r\\n\u0026#34;); } sb.append(\u0026#34; @Column\\r\\n\u0026#34;); sb.append(\u0026#34;\\tprivate \u0026#34; + sqlType2JavaType(colTypes[i]) + \u0026#34; \u0026#34; + toStr(colNames[i]) + \u0026#34;;\\r\\n\u0026#34;); } } /** * @param sb * @description 生成所有get/set方法 * @author paul * @date 2017年8月18日 下午5:14:47 * @update 2017年8月18日 下午5:14:47 * @version V1.0 */ private void processAllMethod(StringBuffer sb) { for (int i = 0; i \u0026lt; colNames.length; i++) { sb.append(\u0026#34;\\tpublic void set\u0026#34; + toUperFirst(colNames[i]) + \u0026#34;(\u0026#34; + sqlType2JavaType(colTypes[i]) + \u0026#34; \u0026#34; + toStr(colNames[i]) + \u0026#34;){\\r\\n\u0026#34;); sb.append(\u0026#34;\\t\\tthis.\u0026#34; + toStr(colNames[i]) + \u0026#34;=\u0026#34; + toStr(colNames[i]) + \u0026#34;;\\r\\n\u0026#34;); sb.append(\u0026#34;\\t}\\r\\n\u0026#34;); sb.append( \u0026#34;\\tpublic \u0026#34; + sqlType2JavaType(colTypes[i]) + \u0026#34; get\u0026#34; + toUperFirst(colNames[i]) + \u0026#34;(){\\r\\n\u0026#34;); sb.append(\u0026#34;\\t\\treturn \u0026#34; + toStr(colNames[i]) + \u0026#34;;\\r\\n\u0026#34;); sb.append(\u0026#34;\\t}\\r\\n\u0026#34;); } } /** * @param str * 传入字符串 * @return * @description 将传入字符串的首字母转成大写 * @author paul * @date 2017年8月18日 下午5:12:12 * @update 2017年8月18日 下午5:12:12 * @version V1.0 */ private String initCap(String str) { char[] ch = str.toCharArray(); if (ch[0] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch[0] \u0026lt;= \u0026#39;z\u0026#39;) ch[0] = (char) (ch[0] - 32); return new String(ch); } /** * @return * @description 将mysql中表名和字段名转换成驼峰形式 * @author paul * @date 2017年8月18日 下午4:55:07 * @update 2017年8月18日 下午4:55:07 * @version V1.0 */ private String getTransStr(String before, boolean firstChar2Upper) { // 不带\u0026#34;_\u0026#34;的字符串,则直接首字母大写后返回 \tif (!before.contains(\u0026#34;_\u0026#34;)) return firstChar2Upper ? initCap(before) : before; String[] strs = before.split(\u0026#34;_\u0026#34;); StringBuffer after = null; if (firstChar2Upper) { after = new StringBuffer(initCap(strs[0])); } else { after = new StringBuffer(strs[0]); } if (strs.length \u0026gt; 1) { for (int i = 1; i \u0026lt; strs.length; i++) after.append(initCap(strs[i])); } return after.toString(); } /** * 首字母大写 */ private String toUperFirst(String s) { if (Character.isUpperCase(s.charAt(0))) return s; else return (new StringBuilder()).append(Character.toUpperCase(s.charAt(0))).append(s.substring(1)).toString(); } /** * 直接生成数据库对应字段名 */ private String toStr(String before) { return before; } /** * @return * @description 查找sql字段类型所对应的Java类型 * @author paul * @date 2017年8月18日 下午4:55:41 * @update 2017年8月18日 下午4:55:41 * @version V1.0 */ private String sqlType2JavaType(String sqlType) { if (sqlType.equalsIgnoreCase(\u0026#34;bit\u0026#34;)) { return \u0026#34;boolean\u0026#34;; } else if (sqlType.equalsIgnoreCase(\u0026#34;tinyint\u0026#34;)) { return \u0026#34;byte\u0026#34;; } else if (sqlType.equalsIgnoreCase(\u0026#34;smallint\u0026#34;)) { return \u0026#34;short\u0026#34;; } else if (sqlType.equalsIgnoreCase(\u0026#34;int\u0026#34;)) { return \u0026#34;int\u0026#34;; } else if (sqlType.equalsIgnoreCase(\u0026#34;bigint\u0026#34;)) { return \u0026#34;long\u0026#34;; } else if (sqlType.equalsIgnoreCase(\u0026#34;float\u0026#34;)) { return \u0026#34;float\u0026#34;; } else if (sqlType.equalsIgnoreCase(\u0026#34;decimal\u0026#34;) || sqlType.equalsIgnoreCase(\u0026#34;numeric\u0026#34;) || sqlType.equalsIgnoreCase(\u0026#34;real\u0026#34;) || sqlType.equalsIgnoreCase(\u0026#34;money\u0026#34;) || sqlType.equalsIgnoreCase(\u0026#34;smallmoney\u0026#34;)) { return \u0026#34;double\u0026#34;; } else if (sqlType.equalsIgnoreCase(\u0026#34;varchar\u0026#34;) || sqlType.equalsIgnoreCase(\u0026#34;char\u0026#34;) || sqlType.equalsIgnoreCase(\u0026#34;nvarchar\u0026#34;) || sqlType.equalsIgnoreCase(\u0026#34;nchar\u0026#34;) || sqlType.equalsIgnoreCase(\u0026#34;text\u0026#34;)) { return \u0026#34;String\u0026#34;; } else if (sqlType.equalsIgnoreCase(\u0026#34;datetime\u0026#34;)) { return \u0026#34;Date\u0026#34;; } else if (sqlType.equalsIgnoreCase(\u0026#34;image\u0026#34;)) { return \u0026#34;Blod\u0026#34;; } return null; } /** * * @description 生成方法 * @author paul * @date 2017年8月18日 下午2:04:20 * @update 2017年8月18日 下午2:04:20 * @version V1.0 * @throws Exception */ private void generate() throws Exception { // 与数据库的连接 \tConnection con; PreparedStatement pStemt = null; Class.forName(DRIVER); con = DriverManager.getConnection(URL, NAME, PASS); System.out.println(\u0026#34;connect database success...\u0026#34;); // 获取数据库的元数据 \tDatabaseMetaData db = con.getMetaData(); // 是否有指定生成表，有指定则直接用指定表，没有则全表生成 \tList\u0026lt;String\u0026gt; tableNames = new ArrayList\u0026lt;\u0026gt;(); if (generateTables == null) { // 从元数据中获取到所有的表名 \tResultSet rs = db.getTables(null, null, null, new String[] { \u0026#34;TABLE\u0026#34; }); while (rs.next()) tableNames.add(rs.getString(3)); } else { for (String tableName : generateTables) tableNames.add(tableName); } String tableSql; PrintWriter pw = null; for (int j = 0; j \u0026lt; tableNames.size(); j++) { tableName = tableNames.get(j); tableSql = SQL + tableName; pStemt = con.prepareStatement(tableSql); ResultSetMetaData rsmd = pStemt.getMetaData(); int size = rsmd.getColumnCount(); colNames = new String[size]; colTypes = new String[size]; colSizes = new int[size]; // 获取所需的信息 \tfor (int i = 0; i \u0026lt; size; i++) { colNames[i] = rsmd.getColumnName(i + 1); colTypes[i] = rsmd.getColumnTypeName(i + 1); if (colTypes[i].equalsIgnoreCase(\u0026#34;datetime\u0026#34;)) needUtil = true; if (colTypes[i].equalsIgnoreCase(\u0026#34;image\u0026#34;) || colTypes[i].equalsIgnoreCase(\u0026#34;text\u0026#34;)) needSql = true; colSizes[i] = rsmd.getColumnDisplaySize(i + 1); } // 解析生成class的所有内容 \tString content = parse(); // 输出生成文件 \tFile directory = new File(\u0026#34;\u0026#34;); String dirName = directory.getAbsolutePath() + \u0026#34;/src/main/java/\u0026#34; + packageOutPath.replace(\u0026#34;.\u0026#34;, \u0026#34;/\u0026#34;); File dir = new File(dirName); if (!dir.exists() \u0026amp;\u0026amp; dir.mkdirs()) System.out.println(\u0026#34;generate dir 【\u0026#34; + dirName + \u0026#34;】\u0026#34;); String javaPath = dirName + \u0026#34;/\u0026#34; + getTransStr(tableName, true) + \u0026#34;.java\u0026#34;; FileWriter fw = new FileWriter(javaPath); pw = new PrintWriter(fw); pw.println(content); pw.flush(); System.out.println(\u0026#34;create class 【\u0026#34; + tableName + \u0026#34;】\u0026#34;); } if (pw != null) pw.close(); } /** * @param args * @description 执行方法 * @author paul * @date 2017年8月18日 下午2:03:35 * @update 2017年8月18日 下午2:03:35 * @version V1.0 */ public static void main(String[] args) { try { INSTANCE.generate(); System.out.println(\u0026#34;generate classes success!\u0026#34;); } catch (Exception e) { e.printStackTrace(); } } }   读取文件内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** * 获取文件内容 * @param fileName * @return */ public static String readFileContent(String fileName) { File file = new File(fileName); BufferedReader reader = null; StringBuffer sbf = new StringBuffer(); try { reader = new BufferedReader(new FileReader(file)); String tempStr; while ((tempStr = reader.readLine()) != null) { sbf.append(tempStr); } reader.close(); return sbf.toString(); } catch (IOException e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e1) { e1.printStackTrace(); } } } return sbf.toString(); }   springboot不要数据源启动 1  @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})   随springboot启动执行 1  implements ApplicationRunner   ","description":" ","id":5,"section":"posts","tags":["Java基础"],"title":"【工具类合集】","uri":"https://lu-dashuai.github.io/posts/blogs/%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%90%88%E9%9B%86/"},{"content":"python appium环境搭建  https://www.cnblogs.com/myal/p/10839665.html  pip install Appium_Python_Client appium 下载  链接\n提取码：44kx  基础代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207  import sys,random,os,time from appium import webdriver \u0026#39;\u0026#39;\u0026#39;开始声明全局变量\u0026#39;\u0026#39;\u0026#39; # 子模拟器设备号 DEVICE_ID = \u0026#39;127.0.0.1:62025\u0026#39; # 安卓版本 ANDROID_VERSION = \u0026#34;7.1.2\u0026#34; # 母模拟器编号 FATHER_NO = \u0026#34;mother\u0026#34; # 子模拟器编号 SON_NO = \u0026#34;myphone\u0026#34; # python 文件根路径 PATH = \u0026#34;D://bds任务//meituan//hook代码//appnium//\u0026#34; NOXPATH = \u0026#34;D://NOX//bin//\u0026#34; cmd = \u0026#39;\u0026#39; # 获取driver driver = None \u0026#39;\u0026#39;\u0026#39;执行cmd的方法\u0026#39;\u0026#39;\u0026#39; def do_cmd(cmd): # 内存 try: res = os.popen(cmd) print(\u0026#39;===========\u0026gt;\u0026#39;+\u0026#39;命令：\u0026#39;+cmd + \u0026#39;---执行结果：\u0026#39;+\u0026#39;\u0026#39;) print(\u0026#39;---\u0026gt;\u0026#39;) out = res.read() # 获得输出字符串 print(out) print(\u0026#39;====================================================\u0026#39;) print() res.close() except BaseException: print(\u0026#39;?????????????????????????????????????错了\u0026#39;+cmd) \u0026#39;\u0026#39;\u0026#39;启动app\u0026#39;\u0026#39;\u0026#39; def startApp(): desired_caps = { \u0026#39;platformName\u0026#39;: \u0026#39;Android\u0026#39;, \u0026#39;platformVersion\u0026#39;: ANDROID_VERSION, \u0026#39;deviceName\u0026#39;: DEVICE_ID, \u0026#39;noReset\u0026#39;:True, \u0026#39;noSign\u0026#39;:\u0026#39;True\u0026#39;, \u0026#39;unicodeKeyboard\u0026#39;:\u0026#39;True\u0026#39;, \u0026#34;resetKeyboard\u0026#34;:\u0026#34;True\u0026#34;, \u0026#39;appPackage\u0026#39;: \u0026#39;com.sankuai.meituan\u0026#39;, \u0026#39;appActivity\u0026#39;: \u0026#39;com.meituan.android.pt.homepage.activity.Welcome\u0026#39; } global driver driver = webdriver.Remote(\u0026#39;127.0.0.1:4723/wd/hub\u0026#39;, desired_caps) \u0026#39;\u0026#39;\u0026#39;睡眠的方法\u0026#39;\u0026#39;\u0026#39; def do_sleep(thing,t): for i in range(t,-1,-1): print(\u0026#39;\\r\u0026#39;,thing+\u0026#39;--倒计时还有 %s秒！\u0026#39; % str(i).zfill(2),end=\u0026#39;\u0026#39;) time.sleep(1) \u0026#39;\u0026#39;\u0026#39;滑动\u0026#39;\u0026#39;\u0026#39; def swipe(): global driver size = driver.get_window_size() width = size[\u0026#39;width\u0026#39;] height = size[\u0026#39;height\u0026#39;] driver.swipe(width/2,height*9/10,width/2,height/20,1000) # do_sleep(\u0026#34;滑动\u0026#34;+(height/20-height*9/10)+\u0026#34;像素\u0026#34;,1) def begin(): do_sleep(\u0026#39;开始执行python 脚本...\u0026#39;,3) # 关闭所有cmd try: cmd = \u0026#39;taskkill /f /im cmd.exe /t\u0026#39; do_cmd(cmd) do_sleep(\u0026#39;关闭所有cmd\u0026#39;,3) except BaseException: print(\u0026#39;??????????关闭所有cmd\u0026#39;) # 关闭所有模拟器 try: cmd = \u0026#39;cmd /c \u0026#39;+NOXPATH+\u0026#39;NoxConsole.exe quitall\u0026#39; do_cmd(cmd) do_sleep(\u0026#39;关闭所有模拟器\u0026#39;,30) except BaseException: print(\u0026#39;???????关闭所有模拟器\u0026#39;) # 移除克隆的模拟器 try: cmd = \u0026#39;cmd /c \u0026#39;+NOXPATH+\u0026#39;NoxConsole.exe remove -name:\u0026#39;+SON_NO do_cmd(cmd) do_sleep(\u0026#39;移除克隆的模拟器\u0026#39;,5) except BaseException: print(\u0026#39;????????移除克隆的模拟器\u0026#39;) # 开始克隆模拟器 try: cmd = \u0026#34;cmd /c \u0026#34;+NOXPATH+\u0026#34;NoxConsole.exe copy -name:\u0026#34;+SON_NO+\u0026#34; -from:\u0026#34;+FATHER_NO do_cmd(cmd) do_sleep(\u0026#39;开始克隆模拟器\u0026#39;,10) except BaseException: print(\u0026#39;????????开始克隆模拟器\u0026#39;) # 启动模拟器 try: cmd = \u0026#34;cmd /c \u0026#34;+NOXPATH+\u0026#34;NoxConsole.exe launch -name:\u0026#34;+SON_NO do_cmd(cmd) do_sleep(\u0026#39;启动模拟器\u0026#39;,30) except BaseException: print(\u0026#39;????????启动模拟器\u0026#39;) # 执行adb命令 try: for i in range(3): cmd = \u0026#34;cmd /c adb connect \u0026#34;+DEVICE_ID do_cmd(cmd) do_sleep(\u0026#39;adb链接模拟器,第\u0026#39;+str(i)+\u0026#39;次\u0026#39;,2) except BaseException: print(\u0026#39;????????执行adb命令\u0026#39;) # 启动appnium，打开美团  try: startApp() do_sleep(\u0026#39;启动appnium，打开美团 \u0026#39;,10) except BaseException: print(\u0026#39;????????启动appnium，打开美团 \u0026#39;) else: print(\u0026#39;来了老弟。。\u0026#39;) global driver # 点击同意 try: driver.find_element_by_id(\u0026#39;com.sankuai.meituan:id/permission_agree_btn\u0026#39;).click() do_sleep(\u0026#39;点击同意成功...\u0026#39;,20) except BaseException: print(\u0026#39;????????点击同意 \u0026#39;) else: print(\u0026#39;2来了老弟。。\u0026#39;) # 切换城市 try: driver.find_element_by_xpath(\u0026#34;//*[@text=\u0026#39;鞍山\u0026#39;]\u0026#34;).click() do_sleep(\u0026#39;切换城市成功...\u0026#39;,10) except BaseException: print(\u0026#39;????????切换城市成功...\u0026#39;) # 关闭红包 try: driver.find_element_by_xpath(\u0026#34;//*[@text=\u0026#39;8HP3u6fvxcwMoAAAAASUVORK5CYII=\u0026#39;]\u0026#34;).click() do_sleep(\u0026#39;大红包关闭成功...\u0026#39;,5) except BaseException: try: driver.find_element_by_xpath(\u0026#34;//*[@content-desc=\u0026#39;外卖\u0026#39;]\u0026#34;).click() print(\u0026#34;确实没出来大红包，点击外卖成功...\u0026#34;) do_sleep(\u0026#34;点击外卖成功...\u0026#34;,15) except BaseException: print(\u0026#39;确实没出来大红包，点击外卖成功...\u0026#39;) # 点击外卖 try: driver.find_element_by_xpath(\u0026#34;//*[@content-desc=\u0026#39;外卖\u0026#39;]\u0026#34;).click() do_sleep(\u0026#34;点击外卖成功\u0026#34;, 15) except BaseException: print(\u0026#39;????????点击外卖...\u0026#39;) # 去掉新人专享红包 try: driver.find_element_by_id(\u0026#34;com.sankuai.meituan:id/close\u0026#34;).click() do_sleep(\u0026#34;去掉新人专享红包成功\u0026#34;, 2) except BaseException: print(\u0026#39;????????去掉新人专享...\u0026#39;) # 启动frida服务  try: cmd = \u0026#34;cmd /c start start_frida_server.bat \u0026#34; + DEVICE_ID os.system(cmd) do_sleep(\u0026#39;启动frida服务\u0026#39;,10) except BaseException: print(\u0026#39;????????启动frida服务...\u0026#39;) # 开始滑动 try: for i in range(4): swipe() do_sleep(\u0026#34;滑动第\u0026#34;+str(i+1)+\u0026#34;次\u0026#34;, 1) if (i==1) : # //13. 启动美团app python服务 cmd = \u0026#34;cmd /c start start_meituan_python.bat \u0026#34;+PATH os.system(cmd) except BaseException: print(\u0026#39;????????启动frida服务...\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: while True: begin() do_sleep(\u0026#34;来了老弟...\u0026#34;,10)   ","description":" ","id":6,"section":"posts","tags":["python","appium"],"title":"Appium脚本 Python","uri":"https://lu-dashuai.github.io/posts/blogs/appium%E8%84%9A%E6%9C%AC-python/"},{"content":"@toc\n1. nginx单纯做域名的代理时配置的解决办法 2. websocket中java类无法依赖注入的解决办法 3. nginx 域名映射对websocket中url的配置影响问题的解决办法 nginx配置 http{ include mime.types; default_type application/octet-stream; //配置websocket时配置以下 //-------websocket开始---------- map $http_upgrade $connection_upgrade { default upgrade; '' close; } //-------websocket结束------- upstream web_pools { server 127.0.0.1:8888;//这里填写端口 } server { listen 80; server_name ihg-tools.bds-analytics.com;//这里填写二级域名 #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://192.168.3.52:8888;//这里填写服务器ip，如果填写localhost将导致cookie丢失 } //配置websocket时添加以下 //-------websocket开始---------- location /websocket { proxy_pass http://192.168.3.52:8888; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_set_header Origin \u0026quot;\u0026quot;; } //-------websocket结束---------- } } js代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  var socket; $(function () { if(typeof(WebSocket) == \u0026#34;undefined\u0026#34;) { layerMsg(\u0026#34;错误\u0026#34;,\u0026#34;您的浏览器不支持WebSocket\u0026#34;); }else{ // layerMsg(\u0026#34;正确\u0026#34;,\u0026#34;您的浏览器支持WebSocket\u0026#34;);  // http://211.152.47.79:8888/websocket  //路径与以上对应，部署服务器可以测试使用http://www.websocket-test.com/  socket = new WebSocket(\u0026#34;ws://ihg-tools.bds-analytics.com/websocket\u0026#34;); //打开事件  socket.onopen = function() { send2service();//打开先看提醒  window.setInterval(\u0026#34;send2service()\u0026#34;,1000*120);//120秒发送一次消息  }; //获得消息事件  socket.onmessage = function(msg) { layerMsg(\u0026#34;警告\u0026#34;,msg.data) //发现消息进入 开始处理前端触发逻辑  }; //关闭事件  socket.onclose = function() { console.log(\u0026#34;Socket已关闭\u0026#34;); }; //发生了错误事件  socket.onerror = function() { layerMsg(\u0026#34;错误\u0026#34;,\u0026#34;Socket发生了错误,此时可以尝试刷新页面\u0026#34;); //此时可以尝试刷新页面  } } }); function send2service() { socket.send(\u0026#34;hi,i am jack!\u0026#34;); }   java代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160  package com.bds.ihgfb.util; import cn.hutool.log.Log; import cn.hutool.log.LogFactory; import com.bds.ihgfb.model.StatusBean; import org.nutz.dao.Dao; import org.nutz.dao.Sqls; import org.nutz.dao.entity.Entity; import org.nutz.dao.impl.NutDao; import org.nutz.dao.impl.SimpleDataSource; import org.nutz.dao.sql.Sql; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; import javax.websocket.*; import javax.websocket.server.ServerEndpoint; import java.io.IOException; import java.util.List; import java.util.concurrent.CopyOnWriteArraySet; /** * className:WebSocketServer * discription: * author:luRuiHua * createTime:2019-07-08 17:06 */ @ServerEndpoint(\u0026#34;/websocket\u0026#34;) @Component public class WebSocketServer { static Log log= LogFactory.get(WebSocketServer.class); //解决websocket依赖注入失败问题---开始-------------------------  // 这里使用静态，让 service 属于类  private static NutDao dao; // 注入的时候，给类的 service 注入  @Autowired @Qualifier(\u0026#34;xiaohongshu\u0026#34;) public void setDao(NutDao dao){ WebSocketServer.dao = dao; } //解决websocket依赖注入失败问题---结束-------------------------  //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。  private static int onlineCount = 0; //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。  private static CopyOnWriteArraySet\u0026lt;WebSocketServer\u0026gt; webSocketSet = new CopyOnWriteArraySet\u0026lt;WebSocketServer\u0026gt;(); //与某个客户端的连接会话，需要通过它来给客户端发送数据  private Session session; /** * 连接建立成功调用的方法*/ @OnOpen public void onOpen(Session session) { this.session = session; webSocketSet.add(this); //加入set中  addOnlineCount(); //在线数加1  log.info(\u0026#34;有新窗口开始监听当前在线人数为\u0026#34; + getOnlineCount()); } /** * 连接关闭调用的方法 */ @OnClose public void onClose() { webSocketSet.remove(this); //从set中删除  subOnlineCount(); //在线数减1  log.info(\u0026#34;有一连接关闭！当前在线人数为\u0026#34; + getOnlineCount()); } /** * 收到客户端消息后调用的方法 * * @param message 客户端发送过来的消息*/ @OnMessage public void onMessage(String message, Session session) { log.info(\u0026#34;收到来自窗口的信息:\u0026#34;+session+\u0026#34;-----\u0026#34;+message); String s = checkXhsFail(); //群发消息  for (WebSocketServer item : webSocketSet) { try { if (\u0026#34;fail\u0026#34;.equals(s)){ sendMessage(\u0026#34;请打开手机，检查是否存在滑块\u0026#34;); } } catch (IOException e) { e.printStackTrace(); } } } /** * * @param session * @param error */ @OnError public void onError(Session session, Throwable error) { log.error(\u0026#34;发生错误\u0026#34;); error.printStackTrace(); } /** * 实现服务器主动推送 */ public void sendMessage(String message) throws IOException { this.session.getBasicRemote().sendText(message); } public static synchronized int getOnlineCount() { return onlineCount; } public static synchronized void addOnlineCount() { WebSocketServer.onlineCount++; } public static synchronized void subOnlineCount() { WebSocketServer.onlineCount--; } public String checkXhsFail(){ System.out.println(\u0026#34;*********************定时任务开始执行*******************\u0026#34;); // Dao dao = getDao();  //创建sql语句  Sql sql = Sqls.create(\u0026#34;select count(0) as count,status from t_note_simple_task group by status\u0026#34;); //设置返回结果  sql.setCallback(Sqls.callback.entities()); Entity\u0026lt;StatusBean\u0026gt; entity = dao.getEntity(StatusBean.class); sql.setEntity(entity); //执行sql语句  dao.execute(sql); //获取返回结果  List\u0026lt;StatusBean\u0026gt; list = sql.getList(StatusBean.class); int count = 0; for (int i =0;i\u0026lt;list.size();i++){ StatusBean statusBean = list.get(i); int status = statusBean.getStatus(); if (status==4){ count = statusBean.getCount(); } } if (count\u0026gt;=1){ System.out.println(\u0026#34;》》推送《《\u0026#34;); return \u0026#34;fail\u0026#34;;//如果存在4，推送消息  }else { return \u0026#34;suc\u0026#34;; } } }   ","description":" ","id":7,"section":"posts","tags":["Nginx","webSocket"],"title":"【Nginx_webSocket反向代理配置】","uri":"https://lu-dashuai.github.io/posts/blogs/nginx_websocket%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"},{"content":"node安装教程  node环境安装  node服务搭建  node服务搭建  使用cnpm替代npm，防止被墙  [cnpm替代npm] (https://blog.csdn.net/wulove52/article/details/85761288)  npm install -g cnpm --registry=https://registry.npm.taobao.org 无脑启动 anyproxy --intercept 以脚本启动 anyproxy --intercept --rule D:\\bds任务\\ele\\server\\anyproxy_cookie.js 项目github 地址 -git\n","description":" ","id":8,"section":"posts","tags":["HTTP/HTTPS协议","Session/Cookie","Node","anyproxy"],"title":"【Anyproxy抓包环境搭建】","uri":"https://lu-dashuai.github.io/posts/blogs/anyproxy%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  \u0026#39;备注： \u0026#39;防止出现错误 On Error Resume Next \u0026#39;vbs代码开始---------------------------------------------- dim nowTime const interval=120 do nowTime=Hour(Now)\u0026amp;\u0026#34;:\u0026#34;\u0026amp;Minute(Now) CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;taskkill /f /im java.exe\u0026#34;, 0 Wscript.Sleep 3000 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node\\begin_0.bat\u0026#34;, 1 Wscript.Sleep 100 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node\\begin_1.bat\u0026#34;, 1 Wscript.Sleep 100 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node\\begin_2.bat\u0026#34;, 1 Wscript.Sleep 100 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node\\begin_3.bat\u0026#34;, 1 Wscript.Sleep 100 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node\\begin_4.bat\u0026#34;, 1 Wscript.Sleep 100 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node\\begin_5.bat\u0026#34;, 1 Wscript.Sleep 100 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node\\begin_6.bat\u0026#34;, 1 Wscript.Sleep 100 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node\\begin_7.bat\u0026#34;, 1 Wscript.Sleep 100 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node_panda\\startjar.bat\u0026#34;, 1 Wscript.Sleep 100 CreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;D:java\\node_panda_2\\startjar.bat\u0026#34;, 1 Wscript.Sleep 100 Wscript.Sleep interval*60*1000 loop   ","description":" ","id":9,"section":"posts","tags":["Shell脚本"],"title":"【Vbs脚本 定时重启】","uri":"https://lu-dashuai.github.io/posts/blogs/vbs%E8%84%9A%E6%9C%AC-%E5%AE%9A%E6%97%B6%E9%87%8D%E5%90%AF/"},{"content":"需求  每天都需要检查的事，交给计算机，本次示例为检查taobao\u0026amp;tmall hook 接口是否正常返回。 http 请求、python 发送邮件模块。  测试邮件代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  # -*- coding: UTF-8 -*- import smtplib from email.mime.text import MIMEText import email.mime.multipart # 第三方 SMTP 服务 mail_host=\u0026#34;smtp.163.com\u0026#34; #设置服务器 mail_user=\u0026#34;aluruihua@163.com\u0026#34; #用户名 mail_pass=\u0026#34;\u0026#34; #口令 sender = \u0026#39;aluruihua@163.com\u0026#39; receivers = \u0026#39;aluruihua@163.com\u0026#39; # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码 msg = email.mime.multipart.MIMEMultipart() msg[\u0026#39;From\u0026#39;] = \u0026#34;aluruihua@163.com\u0026#34; # 发送者 msg[\u0026#39;To\u0026#39;] = \u0026#34;aluruihua@163.com\u0026#34; # 接收者 msg[\u0026#39;Subject\u0026#39;] = \u0026#39;第一次使用 Python SMTP 邮件\u0026#39; content = \u0026#39;\u0026#39;\u0026#39; 第一次尝试发送邮件--Python \u0026#39;\u0026#39;\u0026#39; txt = MIMEText(content) msg.attach(txt) try: smtpObj = smtplib.SMTP_SSL(mail_host, 465) #smtpObj = smtplib.SMTP() #smtpObj.connect(mail_host,465) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, msg.as_string()) smtpObj.quit() print(\u0026#34;邮件发送成功\u0026#34;) except smtplib.SMTPException: print(\u0026#34;Error: 无法发送邮件\u0026#34;)   完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  import requests,json,datetime,time import smtplib from email.mime.text import MIMEText import email.mime.multipart # 第三方 SMTP 服务 # 检查是否成功  def check(): ip = \u0026#34;localhost\u0026#34; ip = \u0026#34;\u0026#34; params = {\u0026#39;p\u0026#39;:1,\u0026#39;k\u0026#39;:\u0026#39;饮料\u0026#39;,\u0026#39;cat\u0026#39;:\u0026#39;50103339\u0026#39;} url = \u0026#34;http://\u0026#34;+ip+\u0026#34;:8886/hello\u0026#34; res = requests.get(url, params = params).text # print(res) j = json.loads(res) my_url = j[\u0026#39;url\u0026#39;] my_header = j[\u0026#39;header\u0026#39;] headers = str(my_header).split(\u0026#39;,\u0026#39;) # 获取x_mini_wua url = \u0026#34;http:/:/getwua\u0026#34; x_mini_wua = requests.utils.quote(requests.get(url).text) # print(\u0026#39;my_wua--\u0026gt;%s\u0026#39;,x_mini_wua) params = {} for el in headers: key = el.split(\u0026#39;=\u0026#39;)[0].replace(\u0026#39; \u0026#39;,\u0026#39;\u0026#39;) val = el.split(\u0026#39;=\u0026#39;)[1].replace(\u0026#39; \u0026#39;,\u0026#39;\u0026#39;) params[key] = val if key == \u0026#39;x-mini-wua\u0026#39;: val = x_mini_wua res = requests.get(my_url,headers=params) return res \u0026#39;\u0026#39;\u0026#39;睡眠的方法\u0026#39;\u0026#39;\u0026#39; def do_sleep(thing,t): for i in range(t,-1,-1): print(\u0026#39;\\r\u0026#39;,thing+\u0026#39;--倒计时还有 %s秒！\u0026#39; % str(i).zfill(2),end=\u0026#39;\u0026#39;) time.sleep(1) if __name__ == \u0026#34;__main__\u0026#34;: mail_host=\u0026#34;smtp.163.com\u0026#34; #设置服务器 mail_user=\u0026#34;aluruihua@163.com\u0026#34; #用户名 mail_pass=\u0026#34;\u0026#34; #口令 sender = \u0026#39;aluruihua@163.com\u0026#39; receivers = \u0026#39;aluruihua@163.com\u0026#39; # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码 msg = email.mime.multipart.MIMEMultipart() msg[\u0026#39;From\u0026#39;] = \u0026#34;aluruihua@163.com\u0026#34; # 发送者 msg[\u0026#39;To\u0026#39;] = \u0026#34;aluruihua@163.com\u0026#34; # 接收者 msg[\u0026#39;Subject\u0026#39;] = \u0026#39;taobao\u0026amp;tmall check\u0026#39; content = \u0026#39;\u0026#39;\u0026#39; 第一次尝试发送邮件--Python \u0026#39;\u0026#39;\u0026#39; while True: res = check() text = res.text code = res.status_code if(code==200): msg[\u0026#39;Subject\u0026#39;] = \u0026#39;taobao\u0026amp;tmall check success\u0026#39; content = \u0026#39;状态码--\u0026gt;\u0026#39;+str(code)+\u0026#39;\u0026lt;---【res】---\u0026gt;\u0026#39;+text else: msg[\u0026#39;Subject\u0026#39;] = \u0026#39;taobao\u0026amp;tmall check fail\u0026#39; content = \u0026#39;状态码--\u0026gt;\u0026#39;+str(code)+\u0026#39;\u0026lt;---【res】---\u0026gt;\u0026#39;+text txt = MIMEText(content) msg.attach(txt) try: smtpObj = smtplib.SMTP_SSL(mail_host, 465) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, msg.as_string()) smtpObj.quit() print(\u0026#34;邮件发送成功\u0026#34;) except smtplib.SMTPException: print(\u0026#34;Error: 无法发送邮件\u0026#34;) # 三个小时发送一次 do_sleep(\u0026#39;距离下一次发送邮件..\u0026#39;,60*60*3)   ","description":" ","id":10,"section":"posts","tags":null,"title":"【Python 自定义脚本发送邮件】","uri":"https://lu-dashuai.github.io/posts/blogs/python-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"content":"一句话解释链表  链表是以节点的方式来存储，一个内存地址划分为两部分：data域用来存放数据，next作为指向下一个内存地址的标识； 有序列表，是链式存储，再内存上不一定连续；  实现链表的注意事项  每个节点是一个对象，一个链表是一个对象； 需要使用临时的节点变量来遍历，更改当前的临时节点的指向，来完成遍历； 使用while循环，注意每次结束都要temp = temp.next； 打印节点值时注意，head 为 null，需要从head.next开始遍历；  Java代码实现增删改查 声明节点对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Node{ public int id; public String name; public Node next; //next代表下一个节点类  /** * 构造方法 * @param id * @param name */ public Node(int id,String name){ this.id = id; this.name = name; } @Override public String toString() { return \u0026#34;Node{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   增删改查方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  class SingleLinkedList{ //初始化头节点  private Node head = new Node(0,\u0026#34;\u0026#34;); /** * 简单添加一个node节点 * @param node */ public void add(Node node){ //创建一个临时节点 指向head  Node temp = head; while (true){ if (temp.next == null){//说明到最后了  break; } temp = temp.next; //进行++后移保证循环  } temp.next = node; } /** * 按照id的顺序添加，并且如果id重复，提示已经添加该id，不能重复添加 * @param node */ public void addByOrder(Node node){ Node temp = head; boolean flag = false; while (true){ if (temp.next == null)break; //尾部  if (temp.next.id \u0026gt; node.id) break; // 1---\u0026gt;3 进来2了，此时temp = 1 ，if(1.next.id=3 \u0026gt; 2) 恭喜老铁找到了 temp = 1  if (temp.next.id == node.id){ flag = true; System.out.printf(\u0026#34;id:[%d]已经添加过了，不能重复添加\\n\u0026#34;,node.id); break; } temp = temp.next; } if (!flag){//temp = 1  node.next = temp.next; // 2--\u0026gt;3  temp.next = node;//1---\u0026gt;2  } } /** * 更新某个节点 name * @param node */ public void update(Node node){ Node temp = head; boolean flag = false; while (true){ if (temp.next == null){ System.out.println(\u0026#34;到最后了~~\u0026#34;); break; } if (temp.id == node.id){ flag = !flag; temp.name = node.name; break; } temp = temp.next; } if (!flag){ System.out.printf(\u0026#34;更改时，根本没有这个id【%d】\\n\u0026#34;,node.id); } } /** * 删除某个节点 * @param id */ public void del(int id){ Node temp = head; boolean flag = false; while (true){ if (temp.next == null){ System.out.println(\u0026#34;到最后了~~~\u0026#34;); break; } if (temp.next.id == id){//找到被删除的节点的上一个节点  flag = !flag; temp.next = temp.next.next; break; } temp = temp.next; } if (!flag) System.out.printf(\u0026#34;删除时，没找到id：【%d】\\n\u0026#34;,id); } /** * 遍历单链表 */ public void list(){ Node temp = head.next; while (true){ if (temp == null){ break; } System.out.println(temp); temp = temp.next; } } }   main-\u0026gt;test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  public class SingleLinkedListTest { public static void main(String[] args) { SingleLinkedList singleLinkedList = new SingleLinkedList(); // singleLinkedList.add(new Node(1,\u0026#34;女1\u0026#34;)); // singleLinkedList.add(new Node(2,\u0026#34;女2\u0026#34;)); // singleLinkedList.add(new Node(3,\u0026#34;女3\u0026#34;)); // singleLinkedList.add(new Node(4,\u0026#34;女4\u0026#34;)); // singleLinkedList.add(new Node(3,\u0026#34;女3\u0026#34;));  //乱序加入  singleLinkedList.addByOrder(new Node(1,\u0026#34;女1\u0026#34;)); singleLinkedList.addByOrder(new Node(3,\u0026#34;女3\u0026#34;)); singleLinkedList.addByOrder(new Node(2,\u0026#34;女2\u0026#34;)); singleLinkedList.addByOrder(new Node(4,\u0026#34;女4\u0026#34;)); //重复添加  singleLinkedList.addByOrder(new Node(3,\u0026#34;女3\u0026#34;)); //更改已经存在的id  singleLinkedList.update(new Node(3,\u0026#34;小美女\u0026#34;)); //更改未存在的id  singleLinkedList.update(new Node(10,\u0026#34;小美女\u0026#34;)); //删除存在的id  singleLinkedList.del(1); //删除未存在的id  singleLinkedList.del(11); singleLinkedList.list(); int length = singleLinkedList.getLength(singleLinkedList.getHead()); System.out.println(\u0026#34;length=\u0026#34;+length); Node lastNode = singleLinkedList.findLastNode(singleLinkedList.getHead(), 3); System.out.println(\u0026#34;k--\u0026gt;\u0026#34;+lastNode); } }   拓展 求单链表的有效数据个数  思路：将头节点传入，用.next循环，退出循环条件是 当前变量为null  1 2 3 4 5 6 7 8 9 10 11 12 13  /** * 求单链表的有效数据个数 */ public int getLength(Node head){ if (head.next == null) return 0; int length = 0; Node temp = head.next; while (temp != null) { length++; temp = temp.next; } return length; }   查找单链表的倒数第k个节点  思路：传入头节点和k，先找length，遍历的次数 = length - size （临时变量移动的次数）  1 2 3 4 5 6 7 8 9 10 11 12 13 14  /** * 查找单链表的倒数第k个节点 */ public Node findLastNode(Node head,int k) { if (head.next == null) return null; //第一个节点为null  int length = getLength(head);//获取长度  if (k \u0026lt;= 0 || k \u0026gt; length) return null; //排除不合法情况  Node temp = head.next; for (int i = 0; i \u0026lt; length-k ; i++) { // length = 4 , list = [0,1,2,3], k=2 ,temp=0 ,移动2次=length-k=4-2  temp = temp.next; } return temp; }   ","description":" ","id":11,"section":"posts","tags":["单链表","数据结构"],"title":"【数据结构和算法_单链表的增删改查】","uri":"https://lu-dashuai.github.io/posts/blogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95_%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"},{"content":"一句话解释双向链表  每个数据结点中都有两个指针，分别指向直接后继和直接前驱；  实现双向链表的注意事项  临时中间节点 需要指向head；  Java代码实现增删改查 声明节点对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /** * 初始化节点 */ class HeroNode{ int no; String name; String nickName; HeroNode next; HeroNode pre; public HeroNode(int no, String name, String nickName) { this.no = no; this.name = name; this.nickName = nickName; } @Override public String toString() { return \u0026#34;HeroNode{\u0026#34; + \u0026#34;no=\u0026#34; + no + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, nickName=\u0026#39;\u0026#34; + nickName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   增删改查方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115  class DoubleLinkedList{ //初始化头节点，不存放具体数据  private HeroNode head = new HeroNode(0,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;); /** * 获取头节点 * @return */ public HeroNode getHead(){ return head; } /** * 通过no判断添加节点（有序） */ public void add(HeroNode node){ if (node.no==0){ System.out.println(\u0026#34;no不能为0\u0026#34;); return; } HeroNode tmp = head; //遍历所有节点，判断节点的大小，如果大就往他前面插入  while (true){ if (tmp.next == null){ //遍历到最后了  tmp.next = node; node.pre = tmp; break; } if (tmp.next.no == node.no){ System.out.println(\u0026#34;该节点已经存在\u0026#34;); return; } if (tmp.next.no \u0026gt; node.no){ tmp.next.pre = node; node.next = tmp.next; node.pre = tmp; tmp.next=node; return; } tmp = tmp.next; } } /** * 删除节点 * @param node */ public void delete(HeroNode node){ if (head.next == null){ System.out.println(\u0026#34;该链表为null\u0026#34;); return; } HeroNode tmp = head; while (true){ if (tmp.next == null){ break; } if (tmp.next.no == node.no){ tmp.next.next.pre = tmp; tmp.next = tmp.next.next; } tmp = tmp.next; } } /** * 更改 * @param node */ public void updata(HeroNode node){ HeroNode tmp = head; if (tmp.next == null){ System.out.println(\u0026#34;该链表为null\u0026#34;); return; } while (true){ if (tmp.next==null){ break; } if (tmp.next.no == node.no){ tmp.next.name = node.name; tmp.next.nickName = node.nickName; } tmp = tmp.next; } } /** * 遍历链表 */ public void list(){ //辅助变量  HeroNode temp = head.next; if (head.next == null) { System.out.println(\u0026#34;头节点为null\u0026#34;); return; } while (true){ //判断是否到最后  if (temp == null){ break; } System.out.println(temp); //后移  temp = temp.next; } } }   main-\u0026gt;test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public static void main(String[] args) { HeroNode node1 = new HeroNode(1, \u0026#34;宋江\u0026#34;, \u0026#34;及时雨\u0026#34;); HeroNode node2 = new HeroNode(2, \u0026#34;卢俊义\u0026#34;, \u0026#34;玉麒麟\u0026#34;); HeroNode node4 = new HeroNode(4, \u0026#34;吴用\u0026#34;, \u0026#34;智多星\u0026#34;); DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); doubleLinkedList.add(node1); doubleLinkedList.add(node2); doubleLinkedList.add(node4); // doubleLinkedList.list();  HeroNode node3 = new HeroNode(3, \u0026#34;林冲\u0026#34;, \u0026#34;豹子头\u0026#34;); doubleLinkedList.add(node3); doubleLinkedList.list(); System.out.println(); System.out.println(\u0026#34;========delete============\u0026#34;); doubleLinkedList.delete(node2); doubleLinkedList.list(); System.out.println(); System.out.println(\u0026#34;=======update=============\u0026#34;); HeroNode node5 = new HeroNode(1, \u0026#34;林冲\u0026#34;, \u0026#34;豹子头\u0026#34;); doubleLinkedList.updata(node5); }   ","description":" ","id":12,"section":"posts","tags":["双向链表链表","数据结构"],"title":"【数据结构和算法_双向链表的增删改查】","uri":"https://lu-dashuai.github.io/posts/blogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95_%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"},{"content":"gradle 基本介绍  项目构建工具，没有必要过度吹捧； 依赖哪里找 mvn仓库  比起maven的好处  maven现在已经是行业标准，Gradle是后起之秀； Gradle抛弃了Maven的基于XML的繁琐配置，领域特定语言Groovy的配置，大大简化了构建代码的行数； 各种在Maven中难以下手的事情，在Gradle就是小菜一碟，比如修改现有的构建生命周期，几行配置就完成了，同样的事情，在Maven中你必须编写一个插件；  gradle 环境搭建 下载 下载地址\n配环境变量  Path = %GRADLE_HOME%\\bin; GRADLE_USER_HOME = maven本地仓库的位置  配置Gradle仓库源（使用maven本地仓库）  🍎首先maven仓库的地址得配好  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt; \u0026lt;!-- 本地仓库 --\u0026gt; \u0026lt;localRepository\u0026gt;D:\\maven-repository\u0026lt;/localRepository\u0026gt; \u0026lt;pluginGroups\u0026gt; \u0026lt;/pluginGroups\u0026gt; \u0026lt;proxies\u0026gt; \u0026lt;/proxies\u0026gt; \u0026lt;servers\u0026gt; \u0026lt;/servers\u0026gt; \u0026lt;mirrors\u0026gt; \u0026lt;!-- 阿里云镜像 --\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;/settings\u0026gt;    🍌gradle\n在gradle的目录下找到init.d目录\u0026ndash;\u0026gt; 新建 init.gradle文件，填入下面代码，注意替换本地仓库位置；  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  allprojects { repositories { maven { url \u0026#39;file:///D:/maven_repository\u0026#39;}//这里填写maven本地仓库的位置  mavenLocal() maven { name \u0026#34;Alibaba\u0026#34; ; url \u0026#34;https://maven.aliyun.com/repository/public\u0026#34; } maven { name \u0026#34;Bstek\u0026#34; ; url \u0026#34;http://nexus.bsdn.org/content/groups/public/\u0026#34; } mavenCentral() } buildscript { repositories { maven { name \u0026#34;Alibaba\u0026#34; ; url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39; } maven { name \u0026#34;Bstek\u0026#34; ; url \u0026#39;http://nexus.bsdn.org/content/groups/public/\u0026#39; } maven { name \u0026#34;M2\u0026#34; ; url \u0026#39;https://plugins.gradle.org/m2/\u0026#39; } } } }    🐷repositories 中写的是获取 jar 包的顺序。先是本地的 Maven 仓库路径；接着的 mavenLocal() 是获取 Maven 本地仓库的路径，应该是和第一条一样，但是不冲突；第三条和第四条是从国内和国外的网络上仓库获取；最后的 mavenCentral() 是从Apache提供的中央仓库获取 jar 包。  gradle常见命令  检查依赖并编译打包：gradle build ; 编译跳过测试:gradle build -x test; 编译打包tgz包，跳过测试类:gradle releaseTarGz -x signArchives -x test ; 清理:gradle clean; 编译并打Debug包:gradle assembleDebug; 编译并打Release的包（正式发布）：gradle assembleRelease;  gradle的目录介绍 👍gradlew: gradlew环境的脚本，我们执行就会完成环境一个搭建\n👍build: gradlew 项目构建之后自动生成的一个目录\n👍gradle: 里面有个子目录 wrapper项目成员没有安装gradle就会自动安装gradle，好处就是统一gradle的版本\n👍src: 项目源码，包含程序源码和测试源码\n👍.idea: 存放项目的配置信息。这个文件夹是自动生成，版本控制信息等，包括历史记录\n👍settings.gradle: 针对module的全局配置，它的作用域所包含的所有module是通过settings.gradle来配置\n🍎build.gradle: 这个文件是整个项目的构建脚本，脚本中内容是以Groovy语言来书写的。\n范例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  buildscript {//运行首先执行这段代码  ext {//用于定义动态属性  //sringBootVersion 变量的定义  springBootVersion = \u0026#39;2.0.0.RELEASE\u0026#39; } repositories { //mavenCentral() //官方的中央仓库  maven { //自定义中央仓库 下面是引用阿里的maven中央仓库  url \u0026#39;http://maven.aliyun.com/nexus/content/groups/public\u0026#39; } } dependencies {//依赖，下面是依赖springboot的一个插件  //${springBootVersion} 就是引用上面动态属性的变量  classpath(\u0026#34;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\u0026#34;) } } //使用了的插件 apply plugin: \u0026#39;java\u0026#39; apply plugin: \u0026#39;eclipse\u0026#39; apply plugin: \u0026#39;org.springframework.boot\u0026#39; apply plugin: \u0026#39;io.spring.dependency-management\u0026#39; group = \u0026#39;com.youngman\u0026#39; version = \u0026#39;0.0.1-SNAPSHOT\u0026#39;//项目的版本号,用户可以自定义 sourceCompatibility = 1.8//JDK的版本  repositories { //mavenCentral()  maven { url \u0026#39;http://maven.aliyun.com/nexus/content/groups/public\u0026#39; } } //依赖 dependencies { compile(\u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39;) compile(\u0026#39;org.springframework.boot:spring-boot-starter-security\u0026#39;) compile(\u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39;) testCompile(\u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39;) testCompile(\u0026#39;org.springframework.security:spring-security-test\u0026#39;) }   grovvy语法 参考博客\n 不用括号，不用分号； 定义变量用def； 闭包  ","description":" ","id":13,"section":"posts","tags":["Gradle"],"title":"【Gradle 环境配置及使用】","uri":"https://lu-dashuai.github.io/posts/blogs/gradle-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"content":"环境搭建 一、软件准备（见附件）  Anaconda3-2018.12-Windows-x86_64.exe（安装完成之后默认配置好python3.7的环境变量，及一些常用类库，可以不用单独安装python，如果之前有，会替代原版本）；下载地址 frida-server-12.8.13-android-x86（frida-server之后需要push到模拟器中）下载地址 需要hook的apk； 夜神模拟器，Android-5（frida+python+安卓5是测试后环境）； vscode安装 sdk（支持adb命令就行，不要求版本）  二、安装Anaconda3：  安装时记得勾选，其他直接next安装结束。 cmd输入python显示\n  三、pip下载frida及frida-tools：\n安装frida，需要安装两部分，分别是：frida、frida-tools\n cmd输入命令安装frida（速度较慢可能需要一个多小时）：   pip install frida==12.8.13 参考pip国内镜像的使用，安装frida只用5秒钟。\ncmd安装frida-tools:   pip install frida-tools==7.0.2 注意：\n 因为可能电脑之前安装过比python3.7还要低的版本，本次安装anaconda相当于升级了python，但是工具pip和setuptools没有被升级，所以导致安装frida失败找不到版本号。\n如果pip显示找不到对应版本 应该先升级 pip：\n报错：  命令：\npython -m pip install --upgrade pip 升级setuptools：\n命令：\npip install --upgrade setuptools 升级完就可以继续安装frida和frida-tools，过程较慢，耐心等待。\n查看安装情况\n输入cmd命令：   pip list|find \u0026quot;frida\u0026quot; 四、夜深模拟器环境搭建\n 新建夜深模拟器  安卓版本选择默认5.1.1   安装需要hook的apk 电脑连接模拟器(对应自己的设备号)   adb connect 127.0.0.1:62001 模拟器存入frida-server（放入/data/local/tmp目录下，权限大）   adb -s 127.0.0.1:62001 push frida-server-12.8.13-android-x86 /data/local/tmp 5.端口转发\n adb -s 127.0.0.1:62001 forward tcp:27042 tcp:27042 adb -s 127.0.0.1:62001 forward tcp:27043 tcp:27043 6.修改权限并启动server\n连续输入命令，服务启动，cmd命令不要关闭\n adb -s 127.0.0.1:62001 shell su cd /data/local/tmp chmod 777 frida-server-12.8.1 ./frida-server-12.8.1 破解小tip  android killer 反编译失败解决\nhttps://bitbucket.org/iBotPeaches/apktool/downloads/  https://blog.csdn.net/LVXIANGAN/article/details/84622207\nfrida map===》str  var Map = Java.use('java.util.TreeMap'); var args_map = Java.cast(arguments[0], Map); console.log(args_map.toString()); frida byte====\u0026gt;str   var arr = Java.use(\u0026quot;java.util.Arrays\u0026quot;); console.log('param[1]:'+arr.toString(byt)); 本地ssl证书连接问题\n错误信息大致如下：PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target  解决办法：参考https://blog.csdn.net/gabriel576282253/article/details/81531746\nfrida 查看当前运行包名  Frida-ps -U frida hook 构造方法  var URL = Java.use('java.net.URL'); URL.$init.overload('java.lang.String').implementation=function(a){ console.log(a); // return res; } frida hook 中创建java.lang.Object 数组   var bs = Java.array('byte',bytes); var third = Java.use('java.lang.Integer'); var int_sign = third.valueOf(\u0026quot;2\u0026quot;); var obj = Java.array(\u0026quot;java.lang.Object\u0026quot;,[\u0026quot;4069cb78-e02b-45f6-9f0a-b34ddccf389c\u0026quot;,bs,int_sign]); 查看包名和active  1 2 3  adb shell dumpsys activity | grep \u0026#34;mFoc\u0026#34;   frida 在vscode中有代码提示  在目录下输入命令\nnpm i @types/frida-gum ","description":" ","id":14,"section":"posts","tags":["frida"],"title":"【安卓逆向 Frida学习】","uri":"https://lu-dashuai.github.io/posts/blogs/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-frida%E5%AD%A6%E4%B9%A0/"},{"content":"一句话总结  环形队列解决顺序队列假溢出现象；算法主要为取模；  要求 用数组实现环形队列；  内存上没有环形的结构，因此环形队列实上是数组的线性空间来实现。那当数据到了尾部如何处理呢？它将转回到0位置来处理。这个的转回是通过取模操作来执行的。\n  环形队列解决的问题；  ArrayQueue存在一个问题，假设当尾部插入元素满了，头部又删掉了一些元素，这种情况下，就误认为空间满了，造成了假溢出，实际上头部删除了元素留出了空间。这时候环形队列就解决了这样的一个问题，环形队列的front指针始终指向当前队列的最后位置；end指针始终指向第一个元素的前一个位置为-1，存储元素的时候头部和尾部都可以相互移动，而不必造成假溢出现象，节省了内存空间。  环形队列的小算法  初始化 food = head = 0，size = 5 时 其实有效长度为4； 判断队列空：food = head； 判断队列满：(food + 1) % size == head \u0026ndash;\u0026gt; 给尾加一后对长度取模，就得到下一次的添加的位置\u0026hellip;； 头和尾的添加删除的下一个坐标：(food + 1) % size 考虑取模； 队列的有效长度：(food - head + size) % size \u0026mdash;\u0026gt; 得到尾和头的差值 其实就是获得了长度，加长度考虑取模； 展示当前队列 中 i % size；  一般队列 和 环形队列比较  head头部指针\n🍎一般队列：head头部指针初始值为-1，从队列取数据时，该值依次递增，指向的元素即待取出的数据，而队列的头部数据所在的指针位置为head+1。当head=size-1时，队列最后一个数据取出，此时队列为空。\n🍌环形队列：head头部指针初始值为0，指向的元素既是队列的头部数据也是待取出的数据。从队列取数据时，因逻辑上的闭环，指针可能再次回到前面的位置，不能单一递增处理，需通过取模来重新计算指针的值。 food尾部指针\n🍎一般队列：food尾部指针初始值为-1，队列添加数据时，该值依次递增，当food=size-1时，队列满，无法再添加数据。\n🍌环形队列：food尾部指针初始值为0，指向待添加数据的位置，队列添加数据时，因逻辑上的闭环，指针可能再次回到前面的位置，不能单一递增处理，会出现角标越界异常，需通过取模来重新计算指针的值。 队列空的判断逻辑\n🍎一般队列：food == head时，队列空。\n🍌环形队列：food == head时，队列空。 队列满的判断逻辑\n🍎一般队列：food = size - 1时，队列满。\n🍌环形队列：(food + 1) % size == head时，队列满。  java代码 初始化队列对象 1 2 3 4 5 6 7 8 9 10 11 12 13  class LinkedQueue { private int size; private int head; private int food; private int[] arr; public LinkedQueue(int size) { this.size = size; arr = new int[size]; this.head = 0; this.food = 0; } }   判断是否为null 1 2 3 4  public boolean isNull() { return this.food == this.head; }   判断是否满 1 2 3  public boolean isFull() { return (food + 1) % size == head; }   添加一个数字到队列 1 2 3 4 5 6 7 8 9 10  public void add(int val) { if (isFull()) { System.out.println(\u0026#34;队列已满~~\u0026#34;); return; } arr[food] = val;//给值  food = (food + 1 ) % size; //food向后移一位  System.out.println(\u0026#34;添加成功,food为：\u0026#34; + food); }   删除一个队列 1 2 3 4 5 6 7 8 9  public void del() { if (isNull()) { System.out.println(\u0026#34;队列为null~~~\u0026#34;); return; } int val = arr[head]; this.head = ( head + 1) % size; System.out.println(\u0026#34;删除[\u0026#34;+val+\u0026#34;]成功,head为：\u0026#34; + head); }   返回长度 1 2 3  public int getSize() { return (food - head + size) % size; }   展示当前队列 1 2 3 4 5 6 7  public void show(){ //从head开始，表示循环有效长度次  for (int i = head; i \u0026lt; head + getSize(); i++) { //取余等于拿到真实的 数组内的指针  System.out.println(\u0026#34;arr[\u0026#34;+i%size+\u0026#34;] = \u0026#34;+arr[i%size]); } }   ","description":" ","id":15,"section":"posts","tags":["数据结构"],"title":"【数据结构和算法__数组实现环形队列】","uri":"https://lu-dashuai.github.io/posts/blogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95__%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"},{"content":"链表和数组的区别  数组静态分配内存，链表动态分配内存（静态分布：声明数组的时候，一次性申请固定大小，固定位置的内存；动态分配：来一个节点，就会申请一次内存，通过指针将各个节点串联起来。） 数组在内存中连续，链表不连续；   时间复杂度：为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数；  数组利用下标定位，时间复杂度为O(1),链表定位元素时，时间复杂度为O(n)（因为需要遍历); 数组插入或者删除元素的时间复杂度为O(n)(因为需要连续的移动内存位置),链表的时间复杂度O(1)(只需要改变指针的指向);  数组 数组的优点：  随机访问性强，通过下标快速定位，查找速度快；  数组的缺点：  插入和删除效率低（插入和删除需要移动数据）； 浪费内存（每次申请数组规定数组的大小，如果大小不合理，可能会浪费内存）； 初始化时必须指定长度，不能对单个数组进行扩容；  链表 链表的优点：  增删改速度快（通过指针的指向来进行）； 内存利用率较高，需要时才会申请内存；  链表的缺点：  查找到效率低，必须从第一个开始遍历；  单链表 和 双链表的区别  单链表只有指向下一个节点的指针，也就是只能next； 双链表不但可以next，也可以指向上一个节点；  使用场景  删除单链表的某个节点时，，一定要得到待删除结点的前驱，得到该前驱有两种方法，第一种方法是在定位待删除结点的同时一路保存当前结点的前驱。第二种方法是在定位到待删除结点之后，重新从单链表表头开始来定位前驱。尽管通常会采用方法一。但其实这两种方法的效率是一样的，指针的总的移动操作都会有2*i次。而如果用双向链表，则不需要定位前驱结点。因此指针总的移动操作为i次。 查找时也一样，我们可以借用二分法的思路，从head（首节点）向后查找操作和last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍。   可是为什么市场上单链表的使用多余双链表呢？ 从存储结构来看，每个双链表的节点要比单链表的节点多一个指针，而长度为n就需要 n*length（这个指针的length在32位系统中是4字节，在64位系统中是8个字节） 的空间，这在一些追求时间效率不高应用下并不适应，因为它占用空间大于单链表所占用的空间；这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。  ","description":" ","id":16,"section":"posts","tags":["数据结构","数组","单链表","双链表"],"title":"【数据结构和算法__数组-单链表-双链表】","uri":"https://lu-dashuai.github.io/posts/blogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95__%E6%95%B0%E7%BB%84-%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%8F%8C%E9%93%BE%E8%A1%A8/"},{"content":"说明  创建一个队列的对象，属性为大小、头的指针位置、尾部指针位置、存放队列值得数组； 头部和尾部得指针初始化都为-1。因为size==0时，head 和 food 都为-1，为了兼容这种情况。 当头部指针值 == 尾部指针值 队列为null 比如一个队列的size = 3， 0-\u0026gt;1-\u0026gt;2 这个队列的尾部指针为 2 现在是被填满的情况 缺点：在普通顺序队列中，入队操作就是先将尾指针food后移一个单元(food++)，然后将元素值赋给food单元(data[food]=X)。出队时．则是头指针head后移(head++)。像这样进行了一定数量入队和出队操作后，可能会出现这样的情况：尾指针food已指到数组的最后一个元素．即food==MAXLEN-1．此时若再执行入队操作，便会出现队满“溢出”。然而，由于在此之前可能也执行了若干次出队操作．因而数组的前面部分可能还有很多闲置的元素空间，即这种溢出并非是真的没有可用的存储空间，故称这种溢出现象为“假溢出”。显然，必须要解决这一似溢出的问题，否则顺序队列就没有太多使用价值。 缺点解释：长度为3，先进3个，此时food=2，队列满【正常】，再出一个，此时队列头部空余出来一个位置，但是要是再往里面加入得话，就加不进去了，因为food 已经等于 size-1=2了。  代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154  package jack.queue; import java.util.Scanner; /** * 一些声明信息 * Description: 数组实现队列\u0026lt;br/\u0026gt; * date: 2020/5/18 1:16\u0026lt;br/\u0026gt; * * @author Jack.Lu\u0026lt;br /\u0026gt; * @since JDK 1.8 */ public class ArrQueueTest { public static void main(String[] args) { ArrQueueList arrQueueList = new ArrQueueList(3); boolean bo = false; char c = \u0026#39; \u0026#39;;//接受命令  Scanner scanner = new Scanner(System.in); while (!bo) { System.out.println(\u0026#34;输入[a]添加\u0026#34;); System.out.println(\u0026#34;输入[g]取出\u0026#34;); System.out.println(\u0026#34;输入[h]获取头部的值\u0026#34;); System.out.println(\u0026#34;输入[s]打印队列\u0026#34;); char next = scanner.next().charAt(0); ; switch (next) { case \u0026#39;a\u0026#39;: System.out.println(\u0026#34;请输入一个数字：\u0026#34;); int i = scanner.nextInt(); arrQueueList.add(i); break; case \u0026#39;g\u0026#39;: try { int head = arrQueueList.getHead(); System.out.println(\u0026#34;取出头：\u0026#34; + head); } catch (Exception e) { e.getMessage(); } break; case \u0026#39;h\u0026#39;: try { int head = arrQueueList.head(); System.out.println(\u0026#34;头：\u0026#34; + head); } catch (Exception e) { e.getMessage(); } break; case \u0026#39;s\u0026#39;: arrQueueList.show(); break; default: break; } } } } /** * 创建一个队列 */ class ArrQueueList { private int size;//数组的长度  private int head;//头的坐标  private int food;//尾的坐标  private int[] arr;//数组存放数据  /** * 构造函数初始化数组的大小，并且给head 和 food 都指向 头部 * * @param size */ public ArrQueueList(int size) { this.size = size; arr = new int[size]; head = -1;// 初始化时 都为指针都指向第一个  food = -1; } //下面写增删改查 队列的方法，先写两个 1. 判断是否为null 2. 判断是否满了  /** * 队列是否为null * * @return */ public boolean isNull() { return head == food;//当头部指针值 == 尾部指针值 队列为null  } /** * 队列是否满 * * @return */ public boolean isFull() { return food == size - 1;//比如一个队列的size = 3， 0-\u0026gt;1-\u0026gt;2 这个队列的food = 2 现在是被填满的情况  } /** * 给队列添加一个值 * * @param val */ public void add(int val) { if (isFull()) { System.out.println(\u0026#34;满了~~\u0026#34;); return; } food++; arr[food] = val; } /** * 取出队列的头部 */ public int getHead() { if (isNull()) { throw new RuntimeException(\u0026#34;空的!!!\u0026#34;); } head++; return arr[head]; } /** * 头部的值 * * @return */ public int head() { if (isNull()) { throw new RuntimeException(\u0026#34;空的！！！\u0026#34;); } return arr[head + 1]; } /** * 打印队列 */ void show() { if (isNull()) { System.out.println(\u0026#34;空的！！！\u0026#34;); return; } for (int i = 0; i \u0026lt; arr.length; i++) { System.out.printf(\u0026#34;arr[%d] = %d\\n\u0026#34;, i,arr[i]); } } }   ","description":" ","id":17,"section":"posts","tags":["数据结构","队列"],"title":"【数据结构和算法__数组实现顺序队列】","uri":"https://lu-dashuai.github.io/posts/blogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95__%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/"},{"content":"一句话总结  Queue 先进先出;  要求   了解队列的概念；\n 队列是一个有序列表; 遵循先入先出的原则;    队列的分类；\n 顺序队列：数组； 循环队列：数组； 链式队列：链表；    队列的使用场景；\n 先进先出,线程安全    队列的基本方法；\n     方法名 方法作用 描述     add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常   element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常   offer 添加一个元素并返回true 如果队列已满，则返回false   peek 返回队列头部的元素 如果队列为空，则返回null   poll 移除并返问队列头部的元素 如果队列为空，则返回null   put 添加一个元素 如果队列满，则阻塞   remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常   take 移除并返回队列头部的元素 如果队列为空，则阻塞    ","description":" ","id":18,"section":"posts","tags":["数据结构","队列"],"title":"【数据结构和算法__队列】","uri":"https://lu-dashuai.github.io/posts/blogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95__%E9%98%9F%E5%88%97/"},{"content":"前言  海洋兄一个写前端的同志都买了一个阿里云来学习数据库，苦于linux下安装报错，特把阿里云的账号密码发给我，让我来试着安装一下。我自己的阿里云也是看着教程稀里糊涂的安装好了，也没出一篇博客来记录，这次刚好记录下linux的mysql安装，应该要写的比较详细，毕竟一会还要给海洋兄发过去装逼用。嘻嘻!😊~~~~  常用的linux命令 Docker 进程相关命令  启动docker服务:  systemctl start docker  停止docker服务:  systemctl stop docker  重启docker服务:  systemctl restart docker  查看docker服务状态:  systemctl status docker  设置开机启动docker服务:  systemctl enable docker Docker 镜像相关命令  查看镜像: 查看本地所有的镜像  docker images docker images –q # 查看所用镜像的id  搜索镜像:从网络中查找需要的镜像  docker search 镜像名称  拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。 如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。  docker pull 镜像名称  删除镜像: 删除本地镜像  docker rmi 镜像id # 删除指定本地镜像 docker rmi `docker images -q` # 删除所有本地镜像 Docker 容器相关命令  查看容器  docker ps # 查看正在运行的容器 docker ps –a # 查看所有容器  创建并启动容器  docker run 参数 参数说明：\n• -i：保持容器运行。通常与-t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。\n• -t：为容器重新分配一个伪输入终端，通常与-i 同时使用。\n• -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用dockerexec 进入容器。退出后，容器不会关闭。\n• -it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器\n• \u0026ndash;name：为创建的容器命名。\n 进入容器  docker exec -t -i \u0026lt;id/container_name\u0026gt; /bin/bash  停止容器  docker stop 容器名称  启动容器  docker start 容器名称  删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除  docker rm 容器名称  查看容器信息  docker inspect 容器名称 详细安装步骤 卸载旧mysql  使用SecureCRT.exe来连接，输入公网ip，用户名和密码\u0026hellip;连上了\n 因为他之前安装过mysql，然后安装失败，我需要彻底卸载\u0026hellip;使用以下命令查看当前安装mysql情况，查找以前是否装有mysql  rpm -qa|grep -i mysql 3. 显示安装过，那么下一步删除\nrpm -ev MySQL-client-5.5.25a-1.rhel5 rpm -ev MySQL-server-5.5.25a-1.rhel5  删除失败的话使用下面的命令  rpm -ev MySQL-client-5.5.25a-1.rhel5 --nodeps 或者 rpm -e --noscripts MySQL-client-5.5.25a-1.rhel5 查找之前老版本mysql的目录、并且删除老版本mysql的文件和库  find / -name mysql  查找结果\n  删除目录  rm -rf 目录名 6. 删除配置\n 注意：卸载后/etc/my.cnf不会删除，需要进行手工删除  rm -rf /etc/my.cnf 重新检查安装情况  rpm -qa|grep -i mysql  关于Linux/Unix系统的设计思想：没有消息就是最好的消息  docker安装 1、yum 包更新到最新 yum update 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2 3、 设置yum源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 4、 安装docker，出现输入的界面都按 y yum install -y docker-ce 5、 查看docker版本，验证是否验证成功 docker -v  阿里云官方安装  6. 配置阿里云镜像加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-'EOF' { \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://dq7u363w.mirror.aliyuncs.com\u0026quot;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker docker-mysql的安装  下载最新版  docker pull mysql 查看镜像  docker images 在opt下创建文件夹  cd /opt/ mkdir mysql_docker cd mysql_docker/ echo $PWD 启动mysql容器，在var/lib/docker/containers/下查看容器  docker run --name mysqlserver -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d -i -p 3306:3306 mysql:latest cd /var/lib/docker/containers/ 查看mysql进程  docker ps -a 进入mysql容器，并登陆mysql  docker exec -it mysqlserver bash mysql -uroot -p 开启远程访问权限  use mysql; 命令：select host,user from user; 命令：ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; 命令：flush privileges; 阿里云配置3306端口后，navite直接链接  结束，求表扬🍉 ","description":"","id":19,"section":"posts","tags":["Mysql","Docker"],"title":"【linux下docker_mysql的安装并连接】","uri":"https://lu-dashuai.github.io/posts/blogs/linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85/"},{"content":"枚举介绍（场景，好处，注意事项） 场景  保证对象的数据安全，有些规范保证类的值只为固定的几个值，比如：星期，性别，季节，http状态码。这些都是一对一的关系，而且也是固定的值，我们都知道404是客户端错误，500是服务端错误。如果提供get/set方法来表示，那么404可能会被set成服务器错误(500)，灵活性大但是容易犯错，导致数据不安全。这时如果有规定为404\u0026mdash;\u0026gt;客户端错误，有个一一对应的关系，也无法修改。这就是规范。  好处  数据安全，设定规范； 使用方便，代码简洁；  注意事项  枚举类中的每个数据都可以调用枚举类的所有方法; 所有枚举值都是public , static , final的。注意这一点只是针对于枚举值，我们可以和在普通类里面定义 变量一样定义其它任何类型的非枚举变量，这些变量可以用任何你想用的修饰符。 枚举类继承Enum，所以不能该类不可以继承其他类(java单继承，多实现); 枚举类中的看着像属性的东西，其实都是每一个对象，当枚举类中有抽象方法，那么该类中的创建的类，必须实现抽象方法。  1 2 3 4 5 6 7 8 9 10 11 12  WHITE(\u0026#34;白\u0026#34;,0){//必须实现  @Override public void say() { } }, BLACK(\u0026#34;黑\u0026#34;,1){ @Override public void say() { } }; //抽象方法 public abstract void say();   它不能有public的构造函数，这样做可以保证客户代码没有办法新建一个enum的实例。(保证对象数据安全); Enum默认实现了java.lang.Comparable接口。 Enum还有一个oridinal的方法，这个方法返回枚举值在枚举类种的顺序，这个顺序根据枚举值声明的顺序而定，这里Color.Red.ordinal()返回0。 枚举使用的单例设计模式，构造器私有  代码场景 场景  在编写五子棋程序时，发现黑色和白色可以用枚举来表示，于是学习了枚举，代码如下：  代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  enum Chesspiece{ WHITE(\u0026#34;白\u0026#34;,0),//枚举值直接写死为黑和白  BLACK(\u0026#34;黑\u0026#34;,1); private String color;//枚举值括号后面对应的黑白两个描述  private int type;//枚举值后面的type，其实也可以用ordinal()方法来表示  Chesspiece(String color,int type){//必须私有构造，默认也是私有构造  this.color = color; this.type = type; } public String getColor(){//只提供get方法，保证无法更改其值  return color; } public int getType(){ return type; } @Override public String toString() { return \u0026#34;Chesspiece{\u0026#34; + \u0026#34;color=\u0026#39;\u0026#34; + color + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, type=\u0026#34; + type + \u0026#39;}\u0026#39;; } /** * API 的调用 */ public static void main(String[] args) { //获取下标，重要  int ordinal = Chesspiece.WHITE.ordinal(); System.out.printf(\u0026#34;%d\\n\u0026#34;,ordinal);//0  //获取属性名  String name = Chesspiece.WHITE.name(); System.out.printf(\u0026#34;%s\\n\u0026#34;,name);//WHITE  //重写toString()方法后打印  String white = Chesspiece.WHITE.toString();//本来底层返回的是name  System.out.println(white);//Chesspiece{color=\u0026#39;白\u0026#39;, type=0}  //返回get的结果  int type = Chesspiece.BLACK.getType(); System.out.println(type);//1  String color = Chesspiece.BLACK.getColor(); System.out.println(color);//黑  } }   ","description":"","id":20,"section":"posts","tags":["枚举","Java基础"],"title":"【java基础之__枚举】","uri":"https://lu-dashuai.github.io/posts/blogs/java%E5%9F%BA%E7%A1%80__%E6%9E%9A%E4%B8%BE/"},{"content":"一句话总结  解决二维数组存储无效数据的痛点，节省存储空间。  要求  了解稀疏数组的概念   如果一个数组(包括多维数组)中的大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组，节约空间。  用代码实现稀疏数组转换为二维数组 稀疏数组的使用场景   可以使用稀疏数组来保留类似前面的二维数组(棋盘，地图等)  场景  五子棋盘，解决二维数组存储大量无效数据的问题，可以使存取量变小。  二维数组\u0026amp;稀疏数组  两种都是数据结构  图例  将棋盘实例化成二维数组\n 思路上将二维数组转化为稀疏数组\n 代码中将稀疏数组存盘，转化为二维数组显示   此时稀疏数组的第一行分别为：\n|二维数组的行数 | 二维数组的列数 | 有效值\n|二维数组中的第一个有效值的x值|二维数组中的第一个有效值的y值|有效值的值\n\u0026hellip;  代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271  package com.atguigu.sparsearray; import java.util.Scanner; /** * 一些声明信息 * Description: 五子棋游戏----\u0026gt;稀疏数组 * date: 2020/5/15 14:44\u0026lt;br/\u0026gt; * * @author Jack.Lu\u0026lt;br /\u0026gt; * @since JDK 1.8 */ public class Test { private static int[][] table;//全局二维数组  private static int[][] sparseArr;//全局稀疏数组  private static int num = 0;//记录白棋先下还是黑棋先下  private static int sum = 0;//记录下棋的个数  /** * 用来执行二维数组的代码 * @param args */ // public static void main(String[] args) { // // 1. 创建空五子棋盘 // Scanner scanner = new Scanner(System.in); // System.out.println(\u0026#34;请输入要创建的棋盘【行】数（注意输入数字）：\u0026#34;); // int x = scanner.nextInt(); // System.out.println(\u0026#34;请输入要创建的棋盘【列】数（注意输入数字）：\u0026#34;); // int y = scanner.nextInt(); // createTableNormal(x, y); // // boolean bo = false; // while (!bo) { // if (num % 2 == 0) {//默认白棋先下 // System.out.println(Chesspiece.WHITE.getColor()+\u0026#34;为\u0026#34;+Chesspiece.WHITE.getType()); // System.out.println(\u0026#34;请输入x坐标：\u0026#34;); // x = scanner.nextInt(); // System.out.println(\u0026#34;请输入y坐标：\u0026#34;); // y = scanner.nextInt(); // downTable(x,y,Chesspiece.WHITE.getType()); // }else { // System.out.println(Chesspiece.BLACK.getColor()+\u0026#34;为\u0026#34;+Chesspiece.BLACK.getType()); // System.out.println(\u0026#34;请输入x坐标：\u0026#34;); // x = scanner.nextInt(); // System.out.println(\u0026#34;请输入y坐标：\u0026#34;); // y = scanner.nextInt(); // downTable(x,y,Chesspiece.BLACK.getType()); // } // num++; // } // }  /** * 用于执行稀疏数组的代码 * @param args */ public static void main(String[] args) { // 1. 创建空五子棋盘  Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入要创建的棋盘【行】数（注意输入数字）：\u0026#34;); int x = scanner.nextInt(); System.out.println(\u0026#34;请输入要创建的棋盘【列】数（注意输入数字）：\u0026#34;); int y = scanner.nextInt(); createTableSparseArray(x, y); //2. 将稀疏表 转化为 普通表 输出  SparseArrayToNomal(); boolean bo = false; while (!bo) { if (num % 2 == 0) {//默认白棋先下  System.out.println(Chesspiece.WHITE.getColor() + \u0026#34;为\u0026#34; + Chesspiece.WHITE.getType()); System.out.println(\u0026#34;请输入x坐标：\u0026#34;); x = scanner.nextInt(); System.out.println(\u0026#34;请输入y坐标：\u0026#34;); y = scanner.nextInt(); downSparseTable(x, y, Chesspiece.WHITE.getType()); } else { System.out.println(Chesspiece.BLACK.getColor() + \u0026#34;为\u0026#34; + Chesspiece.BLACK.getType()); System.out.println(\u0026#34;请输入x坐标：\u0026#34;); x = scanner.nextInt(); System.out.println(\u0026#34;请输入y坐标：\u0026#34;); y = scanner.nextInt(); downSparseTable(x, y, Chesspiece.BLACK.getType()); } num++; } } /** * 稀疏数组下棋 * @param x * @param y * @param type */ private static void downSparseTable(int x, int y, int type) { sum = sum +1; int m = sparseArr.length+1;//代表行  int n = sparseArr[0].length;//代表列  int[][] tmp = new int[m][n];//该稀疏数组保持 x 的+1扩容，y还是三行  //原表的拷贝  for (int i=0;i\u0026lt;sparseArr.length;i++){ tmp[i][0] = sparseArr[i][0]; tmp[i][1] = sparseArr[i][1]; tmp[i][2] = sum; } tmp[sum][0]=x; tmp[sum][1]=y; tmp[sum][2]=type; sparseArr = tmp; //打印稀疏数组  System.out.println(\u0026#34;打印稀疏表：\u0026#34;); for (int i = 0; i \u0026lt; sparseArr.length; i++) { //看有几行  for (int j = 0; j \u0026lt; sparseArr[0].length; j++) {//打印每列  System.out.printf(\u0026#34;%d\\t\u0026#34;, sparseArr[i][j]); } System.out.println(); } //将稀疏数组转换为二维数组  SparseArrayToNomal(); } /** * 将初始化稀疏表转化为普通表进行输出 */ private static void SparseArrayToNomal() { //处理稀疏数组第一行数据  int x = sparseArr[0][0]; int y = sparseArr[0][1]; table = new int[x][y];//稀疏表的00为行数，01为列数  //处理稀疏数组第二行开始后的数据  //for 循环 稀疏表 赋值给 二维表  int val = 0; for (int i=1;i\u0026lt;sparseArr.length;i++){ x = sparseArr[i][0];//横坐标  y = sparseArr[i][1];//纵坐标  val = sparseArr[i][2];//值  table[x][y]=val; } System.out.println(\u0026#34;将稀疏表转化为普通表进行输出：\u0026#34;); for (int i = 0; i \u0026lt; table.length; i++) { for (int j = 0; j \u0026lt; table[0].length; j++) { System.out.printf(\u0026#34;%d\\t\u0026#34;,table[i][j]); } System.out.println(); } } /** * 创建五子棋地图 * * @param x 几行 * @param y 几列 */ public static void createTableNormal(int x, int y) { //int的默认值为0  table = new int[x][y]; for (int i = 0; i \u0026lt; x; i++) { //看有几列  for (int j = 0; j \u0026lt; y; j++) {//打印每行  System.out.printf(\u0026#34;%d\\t\u0026#34;, table[i][j]); } System.out.println(); } } /** * 创建五子棋地图 通过稀疏数组 * * @param x * @param y 稀疏数组：一共有三列，坐标为（0,0）表示棋盘的总行数，（0，1）表示棋盘的总列数，（0，2）表示棋盘非0的个数 */ public static void createTableSparseArray(int x, int y) { sparseArr = new int[1][3];//初始化稀疏数组，只有表示行列的值  sparseArr[0][0] = x; sparseArr[0][1] = y; sparseArr[0][2] = sum; //打印稀疏数组  System.out.println(\u0026#34;打印稀疏表：\u0026#34;); for (int i = 0; i \u0026lt; 1; i++) { //看有几行  for (int j = 0; j \u0026lt; 3; j++) {//打印每列  System.out.printf(\u0026#34;%d\\t\u0026#34;, sparseArr[i][j]); } System.out.println(); } } /** * table的展示 */ public static void showTable() { for (int i = 0; i \u0026lt; table.length; i++) { for (int j = 0; j \u0026lt; table[i].length; j++) { System.out.printf(\u0026#34;%d\\t\u0026#34;, table[i][j]); } System.out.println(); } } /** * 进行下棋 * * @param x 放到的行数 * @param y 放到的列数 * @param */ public static void downTable(int x, int y, int type) { table[x][y] = type; showTable(); } } /** *使用枚举来表示黑白色棋子 * */ enum Chesspiece { WHITE(\u0026#34;白\u0026#34;, 1), BLACK(\u0026#34;黑\u0026#34;, 2); private String color; private int type; Chesspiece(String color, int type) { this.color = color; this.type = type; } public String getColor() { return color; } public int getType() { return type; } @Override public String toString() { return \u0026#34;Chesspiece{\u0026#34; + \u0026#34;color=\u0026#39;\u0026#34; + color + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, type=\u0026#34; + type + \u0026#39;}\u0026#39;; } public static void main(String[] args) { //获取下标  int ordinal = Chesspiece.WHITE.ordinal(); System.out.printf(\u0026#34;%d\\n\u0026#34;, ordinal);//0  //获取属性名  String name = Chesspiece.WHITE.name(); System.out.printf(\u0026#34;%s\\n\u0026#34;, name);//WHITE  //重写toString()方法后打印  String white = Chesspiece.WHITE.toString();//本来底层返回的是name  System.out.println(white);//Chesspiece{color=\u0026#39;白\u0026#39;, type=0}  //返回get的结果  int type = Chesspiece.BLACK.getType(); System.out.println(type);//1  String color = Chesspiece.BLACK.getColor(); System.out.println(color);//黑  } }   ","description":"","id":21,"section":"posts","tags":["稀疏数组","数据结构"],"title":"【数据结构和算法__稀疏数组】","uri":"https://lu-dashuai.github.io/posts/blogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95__%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"content":" github地址   因项目还在完善，并有部分密钥，之后开源。   介绍：程序设计初衷，是想解决日常工作中一些每天都要重复工作的内容。例如：   每天都要检查小红书的解密服务是否挂起（发送请求，看是否返回错误的状态码） 每天都要检查淘宝天猫的解密服务是否挂起（发送请求，检查是否返回错误的状态码） 希望每天给张叶发送一封邮件，有关气温，有关生活（爬虫）。 待完善\u0026hellip;   程序设计：   使用springboot、quartz、springboot-email; 需要设计每个线程单独运行，执行一条定时任务。 无任何web界面,后期如果需要，就用vue，写前后端分离的项目。使用nginx解决跨域问题。 后期可以添加需要持久化的操作，就用mybatis-plus。 最好能达到自动化部署（docker）   希望学习到的技术：   springboot-email nginx quartz(重点) docker（重点）  日记 20200412 今天给自己剃了头。\n完成email的单元测试。\n20200413 配置动态定时器，参考github项目; BeanFactoryPostProcessor接口牛逼之处，mybatis和spring集成后自定义mapper接口，没有实现类，但是spring可以自动注入。\n参考博客，看不懂，不要紧，spring的高级特性还有很多地方需要学习，之后慢慢补;  20200415  今天初始化了前端你的项目，表格也写好了，但是还差一些按钮的功能，交给茶姐 完成后台的查询所有有用任务的接口。等待联调。   问题:1. 前后端分离的时候 nginx 解决跨域问题。  20200416   完成淘宝天猫的业务代码的编写，指定为job1;\n  完成小红书的业务代码的编写，指定为job2；\n  corn 表达式的编写，corn测试\n  完成数据库的迁移\n siqi-yaolingsan-san-yaojiuliu 库名：quartz    忘记mysql密码参考博客\n 使用 service 启动：service mysqld start 使用 service 关闭：service mysqld stop 异常：Your password does not satisfy the current policy requirements\n- 参考博客异常解决\n- MySQL只能服务器登录，远程链接失败\n- 远程端口telnet开启测试\n- 给防火墙开启端口    启动、关闭、查看\n 后台启动   java -jar xxx.jar \u0026gt; log.file \u0026amp;  关闭   ps -ef|grep java  查看日志   cat log.file   复制命令\n   pscp xxx root@47.103.3.196:/jack/war 本地发送邮件成功，但是部署到阿里云服务器发送邮件失败。   参考博客  ","description":"","id":22,"section":"posts","tags":["Quartz","Nginx"],"title":"【自定义发送邮件项目】","uri":"https://lu-dashuai.github.io/posts/blogs/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"content":"Hi! I\u0026rsquo;m Jack!😊 ","description":"Yes","id":27,"section":"","tags":null,"title":"About","uri":"https://lu-dashuai.github.io/about/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;script\u0026gt; var btn = document.getElementById(\u0026#34;btn\u0026#34;); var num =5; btn.onclick = function () { btn.disabled = true; var timer = setInterval(autoplay,1000); function autoplay() { num--; if (num\u0026gt;=0){ btn.innerHTML = num + \u0026#34;s后重发\u0026#34;; } else { btn.innerHTML=\u0026#34;重新发送验证码\u0026#34;; btn.disabled = false; clearInterval(timer); num = 5;//给了一个定时器重启的条件;  } } } \u0026lt;/script\u0026gt;   ","description":" ","id":28,"section":"posts","tags":["js"],"title":"【使用js写短信验证的前台效果】","uri":"https://lu-dashuai.github.io/posts/blogs/%E4%BD%BF%E7%94%A8js%E5%86%99%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%9A%84%E5%89%8D%E5%8F%B0%E6%95%88%E6%9E%9C/"},{"content":"github克隆源代码:https://github.com/Lu-dashuai/shiro.git\n参考视频（B站）：https://www.bilibili.com/video/av33332282?p=6\n1.目标： 1.认证拦截：  未登陆的用户都不能访问后台页面，访问的结果是跳转到登陆页面。  2.权限认证：   学生只能访问学生应该访问的页面。老师也同样。\n  表结构\n  项目结构\n  注意：\n   这里我只有用户表。其他表没有创建。角色是自己模拟的。 项目中与Emp有关的都可以删除，那些是测试框架的。  2.操作： 1.整合springboot、mybatis、redis、thyemleaf  我已将在github上上传了一个springboot、mybatis、redis、thyemleaf，整合版的干净框架。可以直接克隆到本地。具体克隆步骤：\nhttps://blog.csdn.net/weixin_43067223/article/details/84632586 框架github地址：https://github.com/Lu-dashuai/springboot-mybatis-redis.git 直接克隆到本地就ok。  2.将项目spring和shiro的整合依赖导入  此时需要更改pom.xml文件  1 2 3 4 5 6  \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    依赖已经导入\n  3.编写初步的shiro的配置类  在这之前请先观看所有的.html页面，看好跳转关系。 在java文件夹下新建com.aaa.rent.shiro目录； 在目录下创建一个类ShiroConfig； 给类加注解 @Configration :声明为配置类； 在类中写三个方法，分别：  创建ShiroFilterFactoryBean;  设置安全管理器 添加shiro的过滤器 被拦截后跳转登陆页面 未授权跳转页面   创建DefaultWebSecurityManager;  关联realm   创建Realm;\n||\n||\n\\ . /    以上三个方法分别加上注解 @Bean;\n 在目录下创建一个UserRealm类，继承AuthorizingRealm 实现两个方法：  doGetAuthorizationInfo:执行授权逻辑。  获取当前登陆的用户 通过用户名查当前用户 获取当前的权限字符 设置只有是这个字符才可以访问   doGetAuthenticationInfo：：执行认证逻辑。  编写shiro判断逻辑，判断用户名密码是否正确      ShiroConfig代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  package com.aaa.rent.shiro; import at.pollux.thymeleaf.shiro.dialect.ShiroDialect; import org.apache.shiro.spring.web.ShiroFilterFactoryBean; import org.apache.shiro.web.mgt.DefaultWebSecurityManager; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; /** * className:ShiroConfig * discription: * author:luRuiHua * createTime:2018-11-30 14:36 * 拦截器作用：如果没登陆或者用户名密码输错，登陆index.html失败，跳转到login.html * 如果登陆成功，可以访问index.html * 不能直接访问user/student----------student授权 * user/teacher---------teacher授权 * user/index * 可以访问user/login * user/toLogin * */ @Configuration//配置类 public class ShiroConfig { /** * 1. 创建ShiroFilterFactoryBean; */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\u0026#34;securityManager\u0026#34;)DefaultWebSecurityManager securityManager) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //设置安全管理器  shiroFilterFactoryBean.setSecurityManager(securityManager); //添加shiro的过滤器  //shiro的内置过滤器：可以实现权限的相关拦截  //常用的过滤器：  //1.anno：无需认证（登陆即可访问）  //2.authc：必须认证才可以访问  //3.user：如果使用remanberMe的功能就可以直接访问  //4.perms：该资源必须得到资源权限才可以访问  //5.role：该资源必须得到角色权限才可以访问  Map filterMap = new HashMap(); //必须登陆才可以访问  //设置哪些页面必须授权后才可以登陆  filterMap.put(\u0026#34;/user/student\u0026#34;,\u0026#34;perms[2]\u0026#34;);//学生页面  filterMap.put(\u0026#34;/user/teacher\u0026#34;,\u0026#34;perms[1]\u0026#34;);//老师页面  filterMap.put(\u0026#34;/user/index\u0026#34;,\u0026#34;authc\u0026#34;);//首页  //被拦截后跳转登陆页面  shiroFilterFactoryBean.setLoginUrl(\u0026#34;/user/login \u0026#34;); //未授权跳转页面  shiroFilterFactoryBean.setUnauthorizedUrl(\u0026#34;/user/unAuth\u0026#34;); //将filterMap中的url和相关权限交给shiro框架管理  shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; } /** * 2. 创建DefaultWebSecurityManager; */ @Bean(name = \u0026#34;securityManager\u0026#34;) public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\u0026#34;userRealm\u0026#34;)UserRealm userRealm) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //关联realm  securityManager.setRealm(userRealm); return securityManager; } /** * 3. 创建Realm; */ @Bean(name = \u0026#34;userRealm\u0026#34;) public UserRealm getRealm() { return new UserRealm(); } /** * 配置shiroDialect，用于thymeleaf和shiro标签配合使用 */ @Bean public ShiroDialect getShiroDialect() { return new ShiroDialect(); } }   UserRealm类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  package com.aaa.rent.shiro; import com.aaa.rent.service.UserService; import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.*; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.apache.shiro.subject.Subject; import org.springframework.beans.factory.annotation.Autowired; import javax.xml.bind.SchemaOutputResolver; import java.util.List; import java.util.Map; /** * className:UserRealm * discription: * author:luRuiHua * createTime:2018-11-30 14:41 */ public class UserRealm extends AuthorizingRealm { @Autowired private UserService userService; /** * 执行授权逻辑 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { System.out.println(\u0026#34;执行授权逻辑\u0026#34;); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //获取当前登陆的用户  Subject subject = SecurityUtils.getSubject(); //获取用户名  String userName = subject.getPrincipal()+\u0026#34;\u0026#34;; //通过用户名查当前用户  List\u0026lt;Map\u0026gt; maps = userService.selectUserList(userName); //获取当前的权限字符  String roleId = maps.get(0).get(\u0026#34;ROLE_ID\u0026#34;)+\u0026#34;\u0026#34;; //设置只有是这个字符才可以访问  info.addStringPermission(roleId); return info; } /** * 执行认证逻辑 * @param authenticationToken * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { System.out.println(\u0026#34;执行认证逻辑\u0026#34;); //编写shiro判断逻辑，判断用户名密码是否正确  UsernamePasswordToken token = (UsernamePasswordToken)authenticationToken; String username = token.getUsername(); //1.判断用户名  List\u0026lt;Map\u0026gt; mapList = userService.selectUserList(token.getUsername()); if (mapList.size() == 0) { return null; } else { return new SimpleAuthenticationInfo(username, mapList.get(0).get(\u0026#34;PASSWORD\u0026#34;),\u0026#34;\u0026#34;); } } }   5.UserController.java中的逻辑  获取前台页面登陆的账号和密码 获取subject 封装用户数据 执行登陆方法 登陆成功，跳到欢迎页面 用户名不存在的异常 用户名和密码错误  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * 跳转欢迎页面 * @return */ @RequestMapping(\u0026#34;/toLogin\u0026#34;) public String toLogin(String userName, String passWord, Model model) { System.out.println(\u0026#34;账号是：\u0026#34;+userName); //shiro的关键代码，执行认证功能  //1.获取subject  Subject subject = SecurityUtils.getSubject(); //2.封装用户数据  UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(userName, passWord); //3.执行登陆方法  try { //登陆成功  subject.login(usernamePasswordToken); model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;登陆成功\u0026#34;); //跳到欢迎页面  return \u0026#34;back/welcome\u0026#34;; } catch (UnknownAccountException e) {//用户名不存在的异常  model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;用户名不存在\u0026#34;); return \u0026#34;login\u0026#34;; } catch (IncorrectCredentialsException e) {//用户名不存在的异常  model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;用户名和密码错误\u0026#34;); return \u0026#34;login\u0026#34;; } }   如有错误，多多指正，感谢观看！\n","description":" ","id":29,"section":"posts","tags":["SpringBoot","Mybatis","Shiro"],"title":"【SpringBoot Mybatis Shiro Redis整合】","uri":"https://lu-dashuai.github.io/posts/blogs/springboot-mybatis-shiro-redis%E6%95%B4%E5%90%88/"},{"content":"刚创建完一个组织后，想把之前的项目转移到组织的仓库中去咋搞呢？\n先进入到要转移的项目下如图：\n看到图中的settings了吧？点他！！！！然后又如图所示：\n啥都没看到是不是？不要急，拉到最下面，会看到这个：\n看到Transfer了吗？点他！！！！！\n之后又如图所示：\n在这里分别输入要转移的项目名称，第二行输入组织名。输入完毕之后点击 i understand transfer this xxxxxxx。\n之后就可以在自己的组织中看到刚刚转移的项目啦~~~~：\n","description":" ","id":30,"section":"posts","tags":["Git"],"title":"【Github如何将已有的项目转移到组织仓库中去】","uri":"https://lu-dashuai.github.io/posts/blogs/github%E5%A6%82%E4%BD%95%E5%B0%86%E5%B7%B2%E6%9C%89%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%BD%AC%E7%A7%BB%E5%88%B0%E7%BB%84%E7%BB%87%E4%BB%93%E5%BA%93%E4%B8%AD%E5%8E%BB/"},{"content":"问题：  为什么要省略无用的文件？ 这些都是IDE 为了管理我们创建的工程而维护的文件，和开发的代码没有直接关系。最好不要在 Git 中进行追踪，也就是把它们忽略。 同一个团队中很难保证大家使用相同的 IDE 工具，而 IDE 工具不同时，相关工程特定文件就有可能不同。如果这些文件加入版本控制，那么开发时很可能需要为了这些文件解决冲突。  如何在idea中忽略？  最后哪个方框应该是，下载安装插件的按钮。如下：\n 下载后需要重启。 选择.gitignore file\n 点击generate生成模版\n 在这里idea需要忽略哪些文件（这里是我的）。\n.idea:idea的配置文件\n.iml:\ntarget:.class的编译后的文件\n忽略规则请参考：\nhttps://www.cnblogs.com/kevingrace/p/5690241.html  # Created by .ignore support plugin (hsz.mobi) ### Example user template template ### Example user template # IntelliJ project files .idea *.iml target out gen  如有问题，多多指正！  ","description":" ","id":31,"section":"posts","tags":["Git"],"title":"【Idea中的github上传省略无用文件】","uri":"https://lu-dashuai.github.io/posts/blogs/idea%E4%B8%AD%E7%9A%84github%E4%B8%8A%E4%BC%A0%E7%9C%81%E7%95%A5%E6%97%A0%E7%94%A8%E6%96%87%E4%BB%B6/"},{"content":"感谢  感谢b站up主程序🐏提供思维导图，让我在技术路上不迷路~\n  ","description":"用来格式化tag \u0026\u0026 categories","id":33,"section":"myTag","tags":["Java基础","JVM","并发/多线程","数据结构","算法","TCP/UDP协议","HTTP/HTTPS协议","Session/Cookie","Mysql","SQL书写","SQL优化","数据库事务隔离级别","数据库索引","数据库锁","Shell脚本","Git","SVN","Maven","Gradle","Spring","SpringMVC","SpringBoot","Nginx","Tomcat","Redis","RabbitMQ","Dubbo","Mybatis","Nuzt","SpringCloud","Shiro","SSO","Quartz","Docker","Node","Vue","Jenkins"],"title":"需要不断学习的技术栈","uri":"https://lu-dashuai.github.io/mytag/tag-%E9%9C%80%E8%A6%81%E4%B8%8D%E6%96%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":34,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://lu-dashuai.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":35,"section":"gallery","tags":null,"title":"Photo","uri":"https://lu-dashuai.github.io/gallery/photo/"},{"content":"项目状态：已出 项目视频 -B站看片\n功能模块自己看片，本项目价格较低。 另有这个项目的共享单车版本-功能一样，也可cs；\n 项目功能 概览  项目使用技术  jsp servlet mysql hibernate 工具：Intellij IDEA  联系  q: 970638341  ","description":"","id":38,"section":"posts","tags":null,"title":"【毕业设计 共享篮球 or 共享单车】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%85%B1%E4%BA%AB%E7%AF%AE%E7%90%83/"},{"content":"项目状态：未出 项目视频 -B站看片\n项目截图 项目使用技术  开发平台及工具：Windows 10 | IDEA2019 涉及的编程语言：Java | JavaScript | HTML 涉及的框架技术：Struts2 | Spring | Hibernate 其他技术：CSS | JQuery | Ajax | JSON | JSP | Servlet 数据库：MySQL 5.6 服务器：Tomcat 7.x 用到的其他项目：百度富文本编辑器 UEditor  项目简介 摘 要 随着JAVA的普及和流行，J2EE平台也在WEB开发中发挥着越来越大的作用，伴随其的各种新技术如雨后春笋般大量的涌出。为了更好的研究J2EE体系架构，本文采用了业界流行的 Struts、Hibernate和 Spring三种框架，实现了一个功能强大的高性能论坛社区，从而在实践中更深入的理解J2EE。\n关键词 JAVA J2EE 论坛 系统设计 程序设计\n中图分类号：TP393 文献标识码：A\n1需求分析概述\nSSH是Struts、Spring和Hibernate三种框架组合在一起的简称。本文主要目的就是用SSH实现一个高性能，功能强大的论坛社区。从而真正的将这三个框架运用在实际开发的过程中。\n论坛的整体设计与实现是建立在J2EE多层框架基础上的，在做好需求的基础上，要求充分利用J2EE平台下的组件，利用J2EE平台的先进性，让实现充分滿足系统的总体设计，并让最后的系统展现出良好的性能。\n在当今的信息时代，论坛已经成为信息系统一个重要组成部分。一个社区论坛需要完成以下基本功能，发帖，回帖，会员注册，修改已有的话题等。同时还要提供管理员管理的后台界面，管理员具有増加删除主题、管理已经注册的用户、选定版主、删除黑名単上用户、直接对帖子进行修改等功能。但是用传统的模式（如JSP+JavaBean）做出来的论坛也存在许多问题：\n（1）系统难以维护：虽然有些论坛采用了MODEL2，但是老式论坛很少在持久层采用ORM的思想，这将导致持久层开发时间过长，增大系统开发成本，并且可移植性差等一系列问题。甚至有些系统仍然采用MODEL1来开发，那就更难以维护了。\n（2）系统难以扩展：传统论坛业务逻辑与持久层的数据处理部分经常混在一起，很不清晰，这从某种程度上讲增大了系统扩展难度。当你想増加项新功能的时候，往往会被以前那些混合在一起的逻辑搞的不知如何下手。\n（3）系统难以升级：老式论坛采用的有些技术已经落伍，而我们现在用的新型框架都是当今的主流，后面还有开源社区的大力支持，这也为以后系统升级带来了很大的便利。\n（4）系统运行效率不高：由于层次的混乱和设计的不先进性，传统论坛存在一些先天性的缺陷，这导致它的运行效率不高，速度慢。\n所以我们很有必要建立一种设计结构更合理，系统逻辑更清晰，性能更高的新型论坛。\n2系统总体设计概述\n从功能实现方面讲，该社区论坛主要有四个模块，权限管理模块、缓存设计模块、用户功能模块和管理员功能模块。\n2.1权限管理模块概述\n权限管理是该论坛中一个很重要的组成部分，采用Spring的Acegi实现。 Acegi实际上就是基于Spring的IoC机制产生的一种开源框架，后被Spring并入，成为Spring框架的一部分。\n2.1.1角色授权管理\n传统的基于角色的授权管理系统以角色为核心，实现对资源的统一管理，管理起来方便清晰。但是单一的角色授权也存在一些缺点，因为对权限的一些变动就可能需要增加新的角色，容易造成角色泛滥。\n本文的主要角色有游客、普通用户、版主、管理员四种。每种角色对应的都有自己的权限，在分配角色的时候，实际上也就相当于将权限一起分配。如果需要额外的权限授予，就用管理员帐号登陆以后再直接进行授权分配。这样一来，一方面，系统中定义的角色显得简单、清晰，另一方面，直接为用户授权时也显得直观和简单，可以满足实际系统中用户的个性化权限需求。\n2.1.2权限授权管理\n单纯的使用角色—权限分配在上一节里面已经被认为是不适宜的，为了更好的进行权限管理，我们引入了权限授权管理。\n权限授权管理就是说除了通过用户角色分配可以使用户获得权限外，管理员还可以直接对用户进行授权。这个时候，除了用户对应的本身角色所拥有的权限，它还会拥有管理员直接对它进行授权所得到的权限。\n2.2 缓存设计模块概述\n系统内存的使用量总是有一定限制的。在高负载、高压力的应用中最忌讳对内存的过多滥用。有效的使用缓存既可以降低内存的使用总量又可以提升整体应用的速度。\n在大多数的应用服务程序中，用户请求处理的标准流程是将HTTP请求发送到Web服务器。之后服务器解析请求内容的动态页面，并且把访问数据库的请求发送到数据库服务器上在等待数据库返回结果后，整合整个页面并将结果返回。\n当一个页面首次被访问的时候，此时缓存里面还没有该页面，那么缓存将会把此页面保存下来。第二次访问该页面的时候，因为缓存服务器里面已经有了该页面的缓存，就直接从缓存里面取出该页面，从而大大提高了访问速度。\n2.3用户功能模块概述\n用户功能模块主要是针对用户在论坛里面所具有的功能而设计的，一般情况下，用户应该具有下面几个功能：\n（1）注册用户：用户注册是论坛必须具备的业务，只有注册的用户才能享受作为会员的权利，比如发主题帖子，上传或者下载共享资源等。在用户注册的时候对必填信息和已填信息格式要做检测，如果不符合要求需要给出报错提示。\n（2）登录系统：登陆时候要验证用户名和密码，如果都吻合才能进入登陆状态，如果验证不成功将提示用户重新输入。\n（3）管理用户自己的信息：包括用户的详细资料，更改登陆密码等等。需要登陆以后才能更改。\n（4）浏览论坛：被浏览内容设置一定的级别限制，没有登陆的用户可以以游客的身份浏览论坛，但是有些内容会看不到。\n（5）发表主题帖子：用户登陆以后，可以在自己喜欢的版面发表自己的主题。游客不能发。\n（6）回复话题：登陆用户看见自己想回的主题可以回复，没有登陆的用户不允许进行回复。\n（7）版主功能：如果用戶被管理员选为版主，那么就拥有版主功能，版主可以在自己的版面对主题进行管理，觉得好的主题可以置顶，设置为精华帖。同时可以在本版面置公告和通知等功能。\n2.4管理员功能模块概述\n管理员模块针对的是管理功能，管理员做为整个系统的管理者，对系统的维护具有举足轻重的作用。详细的功能如下：\n（1）设置论坛基本信息：如论坛名称，论坛网址，站点地址，站长邮箱等等。\n（2）打开或者关闭论坛：如果论坛需要维护或者因某些原因需要停办，则管理员有权利将该论坛关闭。\n（3）封锁某些IP或者过滤某些不雅文字：有些人在社区发表一些比较不文雅或者政治敏感的话题，为避免引起不必要的麻烦，管理员可以封锁这些IP，禁止它们进入论坛。\n（4）制定发帖子的规范：比如文章的长度，标题最大字数等等。\n（5）用户授权：用户里面设置等级和积分。到达一定积分以后，管理员有权授予用户版主的称号，版主可以协助管理员管理社区。\n3系统功能分析\n论坛本质上是为了用户服务的，从用户的一次完整的使用过程去分析论坛更能直观的反映出论坛的功能。\n用户登陆成功后的页面左边部分是导航条，右边部分是个人信息管理的一些链接和社区里面部分热帖及公告、广告等信息的显示。\n该页面有很多链接，用户点击以后就可以实现对应的功能。\n（1）个人信息管理功能：该块主要实现对用户自身信息功能的管理。用户登陆以后可以修改自己的信息，比如呢称、通讯方式、联系地址等等。同时用户还可以编辑自己的好友。\n（2）社区管理功能：左边导航条里面有显示，非版主点击无效，版主点击以后进入社区管理板块，在这里提供添加社区厂告、通知，添加黑名单等功能。\n（3）浏览社区功能：点击导航条内的二级主题，就可以进入相应的社区，在社区里面，需要提供用户回复帖子和浏览帖子的功能，对于版主，还需要提供版主管理帖子的功能，比如版主能够将某一帖子置顶、锁定、设为精华帖、删除等等。\n（4）社区管理功能：这是版主才有的功能，在这个版块里面，各个版主可以对自己所管的社区进行管理。提供添加公告、系统黑名单、添加广告和社区活动等功能。\n（5）统计功能：用户可以通过此功能，知道当前在线人数等信息。\n用户和管理员的功能的综合，即是该系统功能的主体，在实际的应用中，为了满足使用者的要求，在技术和支出允许的情况下，还需要对系统做不断的修改和增强，使它能够更快更好的满足用户的要求。\n4小结\n本文用SSH多层框架实现了一个功能比较完善的论坛。并对原有的各框架进行了一些扩展和修改以便于更好的提高系统的性能。SSH多层框架的功能还是很强大的，例如Hibernate的延迟加载和缓存功能，Spring的声明式事务管理功能和面向切面功能，Acegi的权限管理等等，充分的利用这些功能，系統会越加完善。同时还使用 OSCache框架实现了系统的缓存功能，进一步提高了系统性能。\n联系  q: 970638341  ","description":"","id":39,"section":"posts","tags":null,"title":"【毕业设计-基于SSH的Java编程学习论坛】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8Essh%E7%9A%84java%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%BA%E5%9D%9B/"},{"content":"项目状态  未出  视频地址  B站看片  系统概要 本系统为用户提供实现了以下功能：\n1.登录功能：\n系统为单用户系统，为用户分配了用户名和密码。用户必须先登录，进入操作界面。用户输入ID和密码，通过服务器验证方可运行，否则显示消息提示。\n2.网站前台功能：\n浏览：博主个人信息、文章； \n发表：留言，评论\n3.网站后台功能： \n发布文章\n文章管理\n页面管理\n评论管理\n分类/标签\n文件管理\n友情链接\n系统设置\n本项目是采用了springboot，spring，mybatis框架进行设计与实现的。项目采用了jdk1.8的版本，web服务器采用tomcat 8，数据库服务器采用了mysql，前台页面的显示使用了JavaScript，CSS，jquery等技术进行编写。使用java面向对象的思想对类和接口进行设计，使网站具有可扩展性，便于维护等优点。\n项目截图 技术选型 后台技术选型  Spring SpringBoot Mybatis 等。。。  前端技术选型  easyUI、Bootstrap 等很多  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat、Git 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.0  联系  q: 970638341  ","description":"","id":40,"section":"posts","tags":null,"title":"【毕业设计 springboot个人博客系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-springboot%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  未出  视频地址  B站看片  系统概要 本系统为用户提供实现了以下功能：\n1.登录功能：\n系统为单用户系统，为用户分配了用户名和密码。用户必须先登录，进入操作界面。用户输入ID和密码，通过服务器验证方可运行，否则显示消息提示。\n2.网站前台功能：\n浏览：博主个人信息、文章； \n发表：留言，评论\n3.网站后台功能： \n用户管理模块：实现用户信息及密码的修改 \n博文的分类与管理模块：实现分类的增、删、改 \n评论管理模块：实现删除评论功能 \n留言管理模块：实现删除、回复评论功能 \n系统管理模块：实现博客版面的定义与管理 博客的数据统计\n本项目是采用了springmvc，spring，mybatis框架进行设计与实现的。项目采用了jdk1.8的版本，web服务器采用tomcat 8，数据库服务器采用了mysql，前台页面的显示使用了JavaScript，CSS，jquery等技术进行编写。使用java面向对象的思想对类和接口进行设计，使网站具有可扩展性，便于维护等优点。\n第一章\t绪论\t1\n第二章 相关技术介绍\t2\n2.1 B/S 简介\t2\n2.2 JAVA 简介\t2\n2.3 JSP 简介\t3\n2.4 springMVC简介\t3\n第三章 可行性分析\t4\n3.1 技术可行性分析\t4\n3.2 经济可行性分析\t4\n3.3 操作可行性\t4\n3.4 法律可行性\t4\n第四章 系统设计\t5\n4.1 系统总流程\t5\n4.2 博主用例\t6\n4.3 游客用例\t7\n4.4 系统类\t9\n4.5 E-R图\t11\n4.6 系统表设计\t14\n第五章 系统实现\t16\n5.1 登录模块\t16\n5.1.1 博主登录\t16\n5.2 博客管理模块：\t19\n5.2.1 博客查询\t19\n5.2.2 博客新建\t21\n5.2.3 博客修改\t23\n5.2.4 博客删除\t25\n5.3 博客类别管理模块\t26\n5.3.1 添加博客类别\t26\n5.3.2 修改博客类别\t28\n5.3.3 删除博客类别\t30\n5.3.4 显示博客类别\t32\n5.4 评论管理模块\t34\n5.4.1 审核评论\t34\n5.4.2 删除评论\t36\n第六章 系统测试\t38\n6.1 前台模块测试\t38\n6.2 后台模块测试\t38\n参考文献\t41\n致 谢\t42\n项目截图 技术选型 后台技术选型  Spring SpringMVC Mybatis 等。。。  前端技术选型  easyUI、Bootstrap 等很多  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat、Git 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.0  联系  q: 970638341  ","description":"","id":41,"section":"posts","tags":null,"title":"【毕业设计 SSM个人博客系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-ssm%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  已出  视频地址  B站看片  系统概要 仓库管理系统总共分为两个大的模块，分别是系统模块和业务模块。其中系统模块和业务模块底下又有其子模块。\n功能模块 一、业务模块 1、客户管理 客户列表 客户分页和模糊查询 客户添加、修改、删除、批量删除 2、供应商管理 供应商列表 供应商分页和模糊查询 供应商添加、修改、删除、批量删除 3、商品管理 商品列表 商品分页和模糊查询 商品添加、修改、删除、商品图片的上传 4、商品进货管理 商品进货列表 商品进货分页和模糊查询 商品进货添加、修改、删除、商品退货 5、商品退货管理 商品退货列表 商品退货分页和模糊查询 商品退货删除 6、商品销售管理 商品销售列表 商品销售分页和模糊查询 商品销售添加、修改、删除、商品销售退货 7、商品销售退货管理 商品销售退货列表 商品销售退货分页和模糊查询 商品销售退货删除 二、系统模块 1、用户登陆 校验用户名、密码以及验证码 登陆成功将登陆信息写入登陆日志 未登录直接访问服务器资源进行拦截 2、菜单管理 全查询菜单和根据左边的树查询不同菜单 菜单的添加、修改、删除 3、角色管理 全查询角色和模糊查询 角色的添加、修改、删除以及给角色分配权限 4、用户管理 全查询用户和模糊查询 用户的添加、修改、删除、重置密码以及给用户分配角色 5、部门管理 全查询部门、模糊查询以及根据左边的树查询不同的部门 部门的添加、修改、删除 技术选型 后台技术选型  SpringBoot Shiro MybatisPlus  前端技术选型  LayUI、DTree  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat、Git 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.0 代码托管平台：GitHub  联系  q: 970638341  ","description":"","id":42,"section":"posts","tags":null,"title":"【毕业设计 仓库管理系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  已出  视频地址  B站看片 这个系统非常适合做毕业设计，页面简单大方，功能完善； 本系统可以更改为任何类别的和商城有关的系统  技术选型 后台技术选型  SpringBoot Mybatis 等\u0026hellip;  前端技术选型  LayUI、DTree  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat、Git 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.0  系统概要 基于 Spring Boot 2.X 及相关技术栈开发。 前台商城系统包含首页门户、商品分类、新品上线、首页轮播、商品推荐、商品搜索、商品展示、购物车、订单结算、订单流程、个人订单管理、会员中心、帮助中心等模块。 后台管理系统包含数据面板、轮播图管理、商品管理、订单管理、会员管理、分类管理、设置等模块。\n项目截图 联系  q: 970638341  ","description":"","id":43,"section":"posts","tags":null,"title":"【毕业设计 在线商城系统-优质】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%A4%A7%E5%9E%8B%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F-%E4%BC%98%E8%B4%A8/"},{"content":"项目状态  已出  视频地址  B站看片 这个系统非常适合做毕业设计，页面简单大方，功能完善； 本系统可以更改为任何类别的和商城有关的系统  技术选型 后台技术选型  SpringBoot Mybatis 等\u0026hellip;  前端技术选型  LayUI、DTree  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat、Git 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.0  系统概要 商城系统总共分为3个大的模块，分别是前台商城页面、个人中心模块和后台业务模块。\n项目截图 联系  q: 970638341  ","description":"","id":44,"section":"posts","tags":null,"title":"【毕业设计 在线商城系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9C%A8%E7%BA%BF%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  未出  视频地址  B站看片  技术  项目用到的相关技术、工具等 开发平台及工具：Windows 8 | IDEA 涉及的编程语言：Java | JavaScript | HTML 涉及的框架技术：Struts2 | Spring | Hibernate 其他技术：Maven | CSS | JQuery | Ajax | JSON | JSP | Servlet 数据库：MySQL 5.6 服务器：Tomcat 7.x  项目截图 联系  q: 970638341  ","description":"","id":45,"section":"posts","tags":null,"title":"【毕业设计 失物招领平台】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%A4%B1%E7%89%A9%E6%8B%9B%E9%A2%86%E5%B9%B3%E5%8F%B0/"},{"content":"项目状态  未出  视频地址  B站看片  系统概要 本系统为用户提供实现了以下功能：\n 登录功能：\n系统为单用户系统，为用户分配了用户名和密码。用户必须先登录，进入操作界面。用户输入ID和密码，通过服务器验证方可运行，否则显示消息提示。 控制台：\n用于展示当前系统所有的数据表格 申购设备：\n提交申请进行设备的购买，查询当前设备状态 设备列表 设备维修 设备类型 申购设备 报废设备查询 维修记录 系统监控  技术选型 后台技术选型  前端采用得是layui框架\u0026mdash;-\u0026gt;传送门：layui官网 admin用的是ok-admin\u0026mdash;-\u0026gt;传送门 ok-admin 前后端全部Ajax数据交互 后端无框架，采用原生servlet/jsp 数据库连接池采用druid  开发环境  JDK 1.8 maven 3.6 mysql 5.6 tomcat 7.0 idea 2019.9  项目截图 联系  q: 970638341  ","description":"","id":46,"section":"posts","tags":null,"title":"【毕业设计 实验室设备管理系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E9%AA%8C%E5%AE%A4%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"content":"项目状态  已出  视频地址  B站看片 这个系统非常适合做毕业设计，页面简单大方，功能完善； 本系统可以更改为任何学校的管理系统，支持定制化更改学校；  技术选型 后台技术选型  Spring JDBC shrio权限管理 servlet、jstl、el表达式  前端技术选型  html jsp javascript jq css bootstrap tree组件  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat 服务器：Tomcat 8.5 数据库：MySQL 5.0  系统概要 商城系统总共分为3个大的模块，分别是管理员模块、宿舍老师模块和学生信息模块。\n 大模块下的小模块功能非常多，项目代码冗余严重，可能需要电脑配置稍高的环境，但是确实良心代码。 小模块功能请看图。⬇  项目截图 联系  q: 970638341  ","description":"","id":47,"section":"posts","tags":null,"title":"【毕业设计 宿舍管理系统】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%AE%BF%E8%88%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"content":"在线预览  B站查看功能演示  主要功能介绍  文章发布系统是一个管理系统，游客注册后可以登录网站属于文章进行评论，管理员可以登录进入管理员中心对网站信息进行管理，对文章进行发布以及管理。极大的方便的网民，是广大网民点开浏览器，输入网址，即可浏览相关信息。  后台技术选型  SpringBoot Mybatis Spring shrio权限管理 servlet、jstl、el表达式  前端技术选型  LayUI、DTree html jsp javascript jq css bootstrap tree组件  开发环境  操作系统：Windows 10 编程语言：Java 开发工具：IDEA、Navicat 项目构建：Maven 3.5.2 服务器：Tomcat 8.5 数据库：MySQL 5.6  模块介绍  前台注册 前台登录 前台新闻查看  国内文章 国际文章 本地文章 娱乐文章 政要文章   管理员登录  个人信息 在线投稿 系统管理   用户登录  前台信息展示 个人信息管理    项目截图 联系 q: 970638341\n","description":"","id":48,"section":"posts","tags":null,"title":"【毕业设计 文章/小说/新闻 发布平台（在线投稿系统）】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%B9%B3%E5%8F%B0/"},{"content":"在线预览  B站查看功能演示  主要功能介绍  新闻管理系统是一个前后台系统，游客注册后可以登录网站可以对文章进行评论，管理员可以登录进入管理员中心对网站信息进行管理，对新闻进行发布以及管理。极大的方便的网民，是广大网民点开浏览器，输入网址，即可浏览相关信息。  技术介绍  由于论文东西非常全面，这里不再详细介绍  模块介绍（有往届论文，各种er图都有） 第一章 绪论\t1\n第二章 相关技术介绍\t3\n2.1 JAVA简介\t3\n2.2 JSP技术简介\t3\n2.3 MySQL数据库简介\t4\n第三章 系统设计\t5\n3.1功能需求\t5\n3.2性能需求\t6\n3.3 可靠性和用户界面需求\t7\n3.4系统E-R模型\t8\n3.5 系统流程分析\t9\n第四章 系统功能实现\t11\n4.1 系统架构\t11\n4.2 系统设计\t12\n4.3 系统数据库设计\t13\n第五章 系统功能实现\t15\n5.1前台新闻发布系统界面\t15\n5.1.1用户注册界面\t16\n5.1.2用户登入界面\t17\n5.1.3用户浏览新闻界面\t18\n5.2后台新闻界面系统\t19\n5.21后台管理界面\t21\n5.2.2新闻栏目管理界面\t21\n5.2.3新闻资讯管理界面\t23\n第六章 系统测试\t27\n6.1测试概述\t27\n6.2测试环境\t27\n6.3测试内容\t27\n第七章 总结\t31\n致 谢\t33\n项目截图 联系 q: 970638341\n","description":"","id":49,"section":"posts","tags":null,"title":"【毕业设计 新闻/文章/小说/ 发布平台（在线投稿系统）二】","uri":"https://lu-dashuai.github.io/posts/bysj/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E6%96%B0%E9%97%BB%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-/"},{"content":"对数据表操作之前备份一下是个好习惯  备份表结构  1  create table table_bak like table_name;   备份表数据  1  insert into table_bak select * from table_name;   删除原来主键字段(如id)  1  alter table table_name drop id;   添加主键，自增，放在第一位  1  alter table table_name add id int(11) primary key auto_increment first;   搞定\n检查没问题的话，备份的表可以删了  1  delete from table_bak;   ","description":"","id":50,"section":"posts","tags":["Mysql"],"title":"【mysql让主键id重新排序】","uri":"https://lu-dashuai.github.io/posts/blogs/mysql%E8%AE%A9%E4%B8%BB%E9%94%AEid%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F/"}]